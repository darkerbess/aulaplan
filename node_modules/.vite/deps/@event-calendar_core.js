import {
  DAY_IN_SECONDS,
  addDay,
  addDuration,
  assign,
  cloneDate,
  createDate,
  createDuration,
  createEventSources,
  createEvents,
  createView,
  derived2,
  hasFn,
  ignore,
  intl,
  intlRange,
  nextClosestDay,
  prevClosestDay,
  runFn,
  setMidnight,
  subtractDay,
  subtractDuration,
  toEventWithLocalDates,
  toISOString,
  toLocalDate,
  toViewWithLocalDates,
  writable2
} from "./chunk-6RAYDXBS.js";
import {
  derived,
  readable,
  writable
} from "./chunk-DY7FSUYH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  add_location,
  append_hydration_dev,
  attr_dev,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_store_value,
  globals,
  group_outros,
  identity,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  prop_dev,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  validate_each_argument,
  validate_slots,
  validate_store
} from "./chunk-K6MJRMI7.js";

// node_modules/@event-calendar/core/src/Calendar.svelte
import "/home/jigs/dev/svelte/school_hub/node_modules/@event-calendar/core/index.css";

// node_modules/@event-calendar/core/src/storage/options.js
function createOptions(plugins) {
  let options = {
    allDayContent: void 0,
    allDaySlot: true,
    buttonText: {
      today: "today"
    },
    date: new Date(),
    dateClick: void 0,
    datesSet: void 0,
    dayHeaderFormat: {
      weekday: "short",
      month: "numeric",
      day: "numeric"
    },
    displayEventEnd: true,
    duration: { weeks: 1 },
    events: [],
    eventBackgroundColor: void 0,
    eventClick: void 0,
    eventColor: void 0,
    eventContent: void 0,
    eventDidMount: void 0,
    eventMouseEnter: void 0,
    eventMouseLeave: void 0,
    eventSources: [],
    eventTimeFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    firstDay: 0,
    flexibleSlotTimeLimits: false,
    // ec option
    headerToolbar: {
      start: "title",
      center: "",
      end: "today prev,next"
    },
    height: "auto",
    hiddenDays: [],
    highlightedDates: [],
    // ec option
    lazyFetching: true,
    loading: void 0,
    locale: void 0,
    monthMode: false,
    nowIndicator: false,
    selectable: false,
    scrollTime: "06:00:00",
    slotDuration: "00:30:00",
    slotHeight: 24,
    // ec option
    slotLabelFormat: {
      hour: "numeric",
      minute: "2-digit"
    },
    slotMaxTime: "24:00:00",
    slotMinTime: "00:00:00",
    theme: {
      allDay: "ec-all-day",
      active: "ec-active",
      bgEvent: "ec-bg-event",
      bgEvents: "ec-bg-events",
      body: "ec-body",
      button: "ec-button",
      buttonGroup: "ec-button-group",
      calendar: "ec",
      compact: "ec-compact",
      content: "ec-content",
      day: "ec-day",
      dayHead: "ec-day-head",
      days: "ec-days",
      event: "ec-event",
      eventBody: "ec-event-body",
      eventTime: "ec-event-time",
      eventTitle: "ec-event-title",
      events: "ec-events",
      extra: "ec-extra",
      handle: "ec-handle",
      header: "ec-header",
      hiddenScroll: "ec-hidden-scroll",
      hiddenTimes: "ec-hidden-times",
      highlight: "ec-highlight",
      icon: "ec-icon",
      line: "ec-line",
      lines: "ec-lines",
      nowIndicator: "ec-now-indicator",
      otherMonth: "ec-other-month",
      sidebar: "ec-sidebar",
      sidebarTitle: "ec-sidebar-title",
      today: "ec-today",
      time: "ec-time",
      title: "ec-title",
      toolbar: "ec-toolbar",
      week: "ec-week",
      withScroll: "ec-with-scroll"
    },
    titleFormat: {
      year: "numeric",
      month: "short",
      day: "numeric"
    },
    view: void 0,
    viewDidMount: void 0,
    views: {}
  };
  for (let plugin of plugins) {
    if ("createOptions" in plugin) {
      plugin.createOptions(options);
    }
  }
  return options;
}
function createParsers(options, plugins) {
  let parsers = {
    buttonText: (input) => is_function(input) ? input(options.buttonText) : input,
    date: (date) => setMidnight(createDate(date)),
    duration: createDuration,
    events: createEvents,
    eventSources: createEventSources,
    hiddenDays: (days) => [...new Set(days)],
    highlightedDates: (dates) => dates.map(createDate),
    scrollTime: createDuration,
    slotDuration: createDuration,
    slotMaxTime: createDuration,
    slotMinTime: createDuration,
    theme: (input) => is_function(input) ? input(options.theme) : input
  };
  for (let plugin of plugins) {
    if ("createParsers" in plugin) {
      plugin.createParsers(parsers, options);
    }
  }
  return parsers;
}
var prev;
function diff(options) {
  let diff2 = [];
  if (prev) {
    for (let name of Object.keys(options)) {
      if (options[name] !== prev[name]) {
        diff2.push([name, options[name]]);
      }
    }
  }
  prev = assign({}, options);
  return diff2;
}

// node_modules/@event-calendar/core/src/storage/stores.js
function activeRange(state) {
  let _activeRange = derived(
    [state._currentRange, state.firstDay, state.monthMode, state.slotMinTime, state.slotMaxTime],
    ([$_currentRange, $firstDay, $monthMode, $slotMinTime, $slotMaxTime]) => {
      let start = cloneDate($_currentRange.start);
      let end = cloneDate($_currentRange.end);
      if ($monthMode) {
        prevClosestDay(start, $firstDay);
        nextClosestDay(end, $firstDay);
      } else if ($slotMaxTime.days || $slotMaxTime.seconds > DAY_IN_SECONDS) {
        addDuration(subtractDay(end), $slotMaxTime);
        let start2 = subtractDay(cloneDate(end));
        if (start2 < start) {
          start = start2;
        }
      }
      return { start, end };
    }
  );
  let debounce = 0;
  derived([_activeRange, state.datesSet], ([$_activeRange, $datesSet]) => {
    if ($datesSet && !debounce) {
      ++debounce;
      tick().then(() => {
        --debounce;
        $datesSet({
          start: toLocalDate($_activeRange.start),
          end: toLocalDate($_activeRange.end),
          startStr: toISOString($_activeRange.start),
          endStr: toISOString($_activeRange.end)
        });
      });
    }
  }).subscribe(noop);
  return _activeRange;
}
function currentRange(state) {
  return derived(
    [state.date, state.duration, state.monthMode, state.firstDay],
    ([$date, $duration, $monthMode, $firstDay]) => {
      let start = cloneDate($date), end;
      if ($monthMode) {
        start.setUTCDate(1);
      } else if ($duration.inWeeks) {
        prevClosestDay(start, $firstDay);
      }
      end = addDuration(cloneDate(start), $duration);
      return { start, end };
    }
  );
}
function viewDates(state) {
  return derived2([state._activeRange, state.hiddenDays], ([$_activeRange, $hiddenDays]) => {
    let dates = [];
    let date = setMidnight(cloneDate($_activeRange.start));
    let end = setMidnight(cloneDate($_activeRange.end));
    while (date < end) {
      if (!$hiddenDays.includes(date.getUTCDay())) {
        dates.push(cloneDate(date));
      }
      addDay(date);
    }
    if (!dates.length && $hiddenDays.length && $hiddenDays.length < 7) {
      state.date.update((date2) => {
        while ($hiddenDays.includes(date2.getUTCDay())) {
          addDay(date2);
        }
        return date2;
      });
      dates = state._viewDates.get();
    }
    return dates;
  });
}
function viewTitle(state) {
  return derived(
    [state.date, state._activeRange, state._titleIntlRange, state.monthMode],
    ([$date, $_activeRange, $_titleIntlRange, $monthMode]) => {
      return $monthMode ? $_titleIntlRange.format($date, $date) : $_titleIntlRange.format($_activeRange.start, subtractDay(cloneDate($_activeRange.end)));
    }
  );
}
function view(state) {
  return derived2([state.view, state._viewTitle, state._currentRange, state._activeRange], (args) => createView(...args));
}
function events(state) {
  let _events = writable([]);
  let abortController;
  let fetching = 0;
  derived(
    [state.events, state.eventSources, state._activeRange, state._fetchedRange, state.lazyFetching, state.loading],
    (values, set) => tick().then(() => {
      let [$events, $eventSources, $_activeRange, $_fetchedRange, $lazyFetching, $loading] = values;
      if (!$eventSources.length) {
        set($events);
        return;
      }
      if (!$_fetchedRange.start || $_fetchedRange.start > $_activeRange.start || $_fetchedRange.end < $_activeRange.end || !$lazyFetching) {
        if (abortController) {
          abortController.abort();
        }
        abortController = new AbortController();
        if (is_function($loading) && !fetching) {
          $loading(true);
        }
        let stopLoading = () => {
          if (--fetching === 0 && is_function($loading)) {
            $loading(false);
          }
        };
        let events2 = [];
        let failure = (e) => stopLoading();
        let success = (data) => {
          events2 = events2.concat(createEvents(data));
          set(events2);
          stopLoading();
        };
        let startStr = toISOString($_activeRange.start);
        let endStr = toISOString($_activeRange.end);
        for (let source of $eventSources) {
          if (is_function(source.events)) {
            let result = source.events({
              start: toLocalDate($_activeRange.start),
              end: toLocalDate($_activeRange.end),
              startStr,
              endStr
            }, success, failure);
            if (result !== void 0) {
              Promise.resolve(result).then(success, failure);
            }
          } else {
            let params = is_function(source.extraParams) ? source.extraParams() : assign({}, source.extraParams);
            params.start = startStr;
            params.end = endStr;
            params = new URLSearchParams(params);
            let url = source.url, headers = {}, body;
            if (["GET", "HEAD"].includes(source.method)) {
              url += (url.includes("?") ? "&" : "?") + params;
            } else {
              headers["content-type"] = "application/x-www-form-urlencoded;charset=UTF-8";
              body = String(params);
            }
            fetch(url, { method: source.method, headers, body, signal: abortController.signal, credentials: "same-origin" }).then((response) => response.json()).then(success).catch(failure);
          }
          ++fetching;
        }
        $_fetchedRange.start = $_activeRange.start;
        $_fetchedRange.end = $_activeRange.end;
      }
    }),
    []
  ).subscribe(_events.set);
  return _events;
}
function now() {
  return readable(createDate(), (set) => {
    let interval = setInterval(() => {
      set(createDate());
    }, 1e3);
    return () => clearInterval(interval);
  });
}
function today(state) {
  return derived(state._now, ($_now) => setMidnight(cloneDate($_now)));
}

// node_modules/@event-calendar/core/src/storage/state.js
var state_default = class {
  constructor(plugins, input) {
    plugins = plugins || [];
    let options = createOptions(plugins);
    let parsers = createParsers(options, plugins);
    for (let [option, value] of Object.entries(options)) {
      this[option] = writable2(value, parsers[option]);
    }
    this._currentRange = currentRange(this);
    this._activeRange = activeRange(this);
    this._fetchedRange = writable({ start: void 0, end: void 0 });
    this._events = events(this);
    this._now = now();
    this._today = today(this);
    this._ignoreClick = writable(false);
    this._intlEventTime = intl(this.locale, this.eventTimeFormat);
    this._intlSlotLabel = intl(this.locale, this.slotLabelFormat);
    this._intlDayHeader = intl(this.locale, this.dayHeaderFormat);
    this._titleIntlRange = intlRange(this.locale, this.titleFormat);
    this._scrollable = writable(false);
    this._viewTitle = viewTitle(this);
    this._viewDates = viewDates(this);
    this._view = view(this);
    this._viewComponent = writable(void 0);
    this._viewClass = writable(void 0);
    this._interaction = writable({});
    this._iEvents = writable([null, null]);
    this._draggable = writable(noop);
    this._resizable = writable(noop);
    this._classes = writable(identity);
    this._iClass = writable(void 0);
    this._scroll = writable(void 0);
    for (let plugin of plugins) {
      if ("createStores" in plugin) {
        plugin.createStores(this);
      }
    }
    if (input.view) {
      this.view.set(input.view);
    }
    let commonOpts = assign({}, options, input);
    parseOpts(commonOpts, this);
    let views = /* @__PURE__ */ new Set([...Object.keys(options.views), ...Object.keys(input.views || {})]);
    for (let view2 of views) {
      let viewOpts = assign({}, options.views[view2] || {}, input.views && input.views[view2] || {});
      parseOpts(viewOpts, this);
      let opts = assign({}, commonOpts, viewOpts);
      this.view.subscribe((newView) => {
        if (newView === view2) {
          this._viewComponent.set(opts.component);
          if (is_function(opts.viewDidMount)) {
            tick().then(() => opts.viewDidMount(this._view.get()));
          }
        }
      });
      for (let key of Object.keys(opts)) {
        if (this.hasOwnProperty(key) && key[0] !== "_") {
          let { set, _set, ...rest } = this[key];
          if (!_set) {
            _set = set;
          }
          this[key] = {
            // Set value in all views
            set: (value) => {
              opts[key] = value;
              set(value);
            },
            _set,
            ...rest
          };
          this.view.subscribe((newView) => {
            if (newView === view2) {
              _set(opts[key]);
            }
          });
        }
      }
    }
  }
};
function parseOpts(opts, state) {
  for (let key of Object.keys(opts)) {
    if (state.hasOwnProperty(key) && key[0] !== "_") {
      if (state[key].parse) {
        opts[key] = state[key].parse(opts[key]);
      }
    }
  }
}

// node_modules/@event-calendar/core/src/Buttons.svelte
var file = "node_modules/@event-calendar/core/src/Buttons.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let button;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[23]
    ] + ""
  );
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[20](
        /*button*/
        ctx[23]
      )
    );
  }
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[6] === /*button*/
      ctx[23] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[23]);
      add_location(button, file, 38, 8, 1447);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", click_handler_1, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx[5][
        /*button*/
        ctx[23]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, $view, buttons*/
      73 && button_class_value !== (button_class_value = /*$theme*/
      ctx[3].button + /*$view*/
      (ctx[6] === /*button*/
      ctx[23] ? " " + /*$theme*/
      ctx[3].active : "") + " ec-" + /*button*/
      ctx[23])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(38:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let button;
  let t_value = (
    /*$buttonText*/
    ctx[5][
      /*button*/
      ctx[23]
    ] + ""
  );
  let t;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      t = claim_text(button_nodes, t_value);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[23]);
      button.disabled = /*isToday*/
      ctx[1];
      add_location(button, file, 36, 8, 1291);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*click_handler*/
          ctx[19],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$buttonText, buttons*/
      33 && t_value !== (t_value = /*$buttonText*/
      ctx2[5][
        /*button*/
        ctx2[23]
      ] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme, buttons*/
      9 && button_class_value !== (button_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(button, "class", button_class_value);
      }
      if (dirty & /*isToday*/
      2) {
        prop_dev(
          button,
          "disabled",
          /*isToday*/
          ctx2[1]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(36:33) ",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let button;
  let i;
  let i_class_value;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      i = claim_element(button_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[23]);
      add_location(i, file, 34, 68, 1198);
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[23]);
      add_location(button, file, 34, 8, 1138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*next*/
          ctx[17],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_class_value !== (button_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(34:32) ",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let button;
  let i;
  let i_class_value;
  let button_class_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      i = element("i");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", { class: true });
      var button_nodes = children(button);
      i = claim_element(button_nodes, "I", { class: true });
      children(i).forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(i, "class", i_class_value = /*$theme*/
      ctx[3].icon + " ec-" + /*button*/
      ctx[23]);
      add_location(i, file, 32, 68, 1046);
      attr_dev(button, "class", button_class_value = /*$theme*/
      ctx[3].button + " ec-" + /*button*/
      ctx[23]);
      add_location(button, file, 32, 8, 986);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, i);
      if (!mounted) {
        dispose = listen_dev(
          button,
          "click",
          /*prev*/
          ctx[16],
          false,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, buttons*/
      9 && i_class_value !== (i_class_value = /*$theme*/
      ctx2[3].icon + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(i, "class", i_class_value);
      }
      if (dirty & /*$theme, buttons*/
      9 && button_class_value !== (button_class_value = /*$theme*/
      ctx2[3].button + " ec-" + /*button*/
      ctx2[23])) {
        attr_dev(button, "class", button_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(32:31) ",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let h2;
  let t;
  let h2_class_value;
  const block = {
    c: function create() {
      h2 = element("h2");
      t = text(
        /*$_viewTitle*/
        ctx[4]
      );
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", { class: true });
      var h2_nodes = children(h2);
      t = claim_text(
        h2_nodes,
        /*$_viewTitle*/
        ctx[4]
      );
      h2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", h2_class_value = /*$theme*/
      ctx[3].title);
      add_location(h2, file, 30, 8, 900);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      append_hydration_dev(h2, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_viewTitle*/
      16)
        set_data_dev(
          t,
          /*$_viewTitle*/
          ctx2[4]
        );
      if (dirty & /*$theme*/
      8 && h2_class_value !== (h2_class_value = /*$theme*/
      ctx2[3].title)) {
        attr_dev(h2, "class", h2_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(h2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(30:32) ",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(29:4) {#if button == ''}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*button*/
      ctx2[23] == ""
    )
      return create_if_block;
    if (
      /*button*/
      ctx2[23] == "title"
    )
      return create_if_block_1;
    if (
      /*button*/
      ctx2[23] == "prev"
    )
      return create_if_block_2;
    if (
      /*button*/
      ctx2[23] === "next"
    )
      return create_if_block_3;
    if (
      /*button*/
      ctx2[23] === "today"
    )
      return create_if_block_4;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(28:0) {#each buttons as button}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let each_1_anchor;
  let each_value = (
    /*buttons*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*buttons, $theme, $_viewTitle, prev, next, isToday, $date, cloneDate, today, $buttonText, $view*/
      229503) {
        each_value = /*buttons*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $duration;
  let $date;
  let $hiddenDays;
  let $_currentRange;
  let $theme;
  let $_viewTitle;
  let $buttonText;
  let $view;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Buttons", slots, []);
  let { buttons } = $$props;
  let { _currentRange, _viewTitle, buttonText, date, duration, hiddenDays, theme, view: view2 } = getContext("state");
  validate_store(_currentRange, "_currentRange");
  component_subscribe($$self, _currentRange, (value) => $$invalidate(18, $_currentRange = value));
  validate_store(_viewTitle, "_viewTitle");
  component_subscribe($$self, _viewTitle, (value) => $$invalidate(4, $_viewTitle = value));
  validate_store(buttonText, "buttonText");
  component_subscribe($$self, buttonText, (value) => $$invalidate(5, $buttonText = value));
  validate_store(date, "date");
  component_subscribe($$self, date, (value) => $$invalidate(2, $date = value));
  validate_store(duration, "duration");
  component_subscribe($$self, duration, (value) => $$invalidate(21, $duration = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(22, $hiddenDays = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(3, $theme = value));
  validate_store(view2, "view");
  component_subscribe($$self, view2, (value) => $$invalidate(6, $view = value));
  let today2 = setMidnight(createDate()), isToday;
  function prev2() {
    let d = subtractDuration($date, $duration);
    if ($hiddenDays.length && $hiddenDays.length < 7) {
      while ($hiddenDays.includes(d.getUTCDay())) {
        subtractDay(d);
      }
    }
    set_store_value(date, $date = d, $date);
  }
  function next() {
    set_store_value(date, $date = addDuration($date, $duration), $date);
  }
  $$self.$$.on_mount.push(function() {
    if (buttons === void 0 && !("buttons" in $$props || $$self.$$.bound[$$self.$$.props["buttons"]])) {
      console.warn("<Buttons> was created without expected prop 'buttons'");
    }
  });
  const writable_props = ["buttons"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Buttons> was created with unknown prop '${key}'`);
  });
  const click_handler = () => set_store_value(date, $date = cloneDate(today2), $date);
  const click_handler_1 = (button) => set_store_value(view2, $view = button, $view);
  $$self.$$set = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
  };
  $$self.$capture_state = () => ({
    getContext,
    createDate,
    cloneDate,
    subtractDay,
    addDuration,
    subtractDuration,
    setMidnight,
    buttons,
    _currentRange,
    _viewTitle,
    buttonText,
    date,
    duration,
    hiddenDays,
    theme,
    view: view2,
    today: today2,
    isToday,
    prev: prev2,
    next,
    $duration,
    $date,
    $hiddenDays,
    $_currentRange,
    $theme,
    $_viewTitle,
    $buttonText,
    $view
  });
  $$self.$inject_state = ($$props2) => {
    if ("buttons" in $$props2)
      $$invalidate(0, buttons = $$props2.buttons);
    if ("_currentRange" in $$props2)
      $$invalidate(7, _currentRange = $$props2._currentRange);
    if ("_viewTitle" in $$props2)
      $$invalidate(8, _viewTitle = $$props2._viewTitle);
    if ("buttonText" in $$props2)
      $$invalidate(9, buttonText = $$props2.buttonText);
    if ("date" in $$props2)
      $$invalidate(10, date = $$props2.date);
    if ("duration" in $$props2)
      $$invalidate(11, duration = $$props2.duration);
    if ("hiddenDays" in $$props2)
      $$invalidate(12, hiddenDays = $$props2.hiddenDays);
    if ("theme" in $$props2)
      $$invalidate(13, theme = $$props2.theme);
    if ("view" in $$props2)
      $$invalidate(14, view2 = $$props2.view);
    if ("today" in $$props2)
      $$invalidate(15, today2 = $$props2.today);
    if ("isToday" in $$props2)
      $$invalidate(1, isToday = $$props2.isToday);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_currentRange*/
    262144) {
      $:
        $$invalidate(1, isToday = today2 >= $_currentRange.start && today2 < $_currentRange.end || null);
    }
  };
  return [
    buttons,
    isToday,
    $date,
    $theme,
    $_viewTitle,
    $buttonText,
    $view,
    _currentRange,
    _viewTitle,
    buttonText,
    date,
    duration,
    hiddenDays,
    theme,
    view2,
    today2,
    prev2,
    next,
    $_currentRange,
    click_handler,
    click_handler_1
  ];
}
var Buttons = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { buttons: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Buttons",
      options,
      id: create_fragment.name
    });
  }
  get buttons() {
    throw new Error("<Buttons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set buttons(value) {
    throw new Error("<Buttons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Buttons_default = Buttons;

// node_modules/@event-calendar/core/src/Toolbar.svelte
var { Object: Object_1 } = globals;
var file2 = "node_modules/@event-calendar/core/src/Toolbar.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_else_block2(ctx) {
  let buttons;
  let current;
  buttons = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(buttons.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(buttons.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(buttons, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_changes.buttons = /*buttons*/
        ctx2[8];
      buttons.$set(buttons_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(buttons, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(28:16) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let div;
  let buttons;
  let div_class_value;
  let current;
  buttons = new Buttons_default({
    props: { buttons: (
      /*buttons*/
      ctx[8]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(buttons.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(buttons.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].buttonGroup);
      add_location(div, file2, 24, 20, 600);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(buttons, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const buttons_changes = {};
      if (dirty & /*sections*/
      1)
        buttons_changes.buttons = /*buttons*/
        ctx2[8];
      buttons.$set(buttons_changes);
      if (!current || dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].buttonGroup)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(buttons.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(buttons.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(buttons);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(24:16) {#if buttons.length > 1}",
    ctx
  });
  return block;
}
function create_each_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*buttons*/
      ctx2[8].length > 1
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(23:12) {#each sections[key] as buttons}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div;
  let t;
  let current;
  let each_value_1 = (
    /*sections*/
    ctx[0][
      /*key*/
      ctx[5]
    ]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {});
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      t = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(div, file2, 21, 8, 488);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      append_hydration_dev(div, t);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, sections, Object*/
      3) {
        each_value_1 = /*sections*/
        ctx2[0][
          /*key*/
          ctx2[5]
        ];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(21:4) {#each Object.keys(sections) as key}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let div_class_value;
  let current;
  let each_value = Object.keys(
    /*sections*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].toolbar);
      add_location(div, file2, 19, 0, 408);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*sections, Object, $theme*/
      3) {
        each_value = Object.keys(
          /*sections*/
          ctx2[0]
        );
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].toolbar)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $headerToolbar;
  let $theme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Toolbar", slots, []);
  let { headerToolbar, theme } = getContext("state");
  validate_store(headerToolbar, "headerToolbar");
  component_subscribe($$self, headerToolbar, (value) => $$invalidate(4, $headerToolbar = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  let sections = { start: [], center: [], end: [] };
  const writable_props = [];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Toolbar> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    Buttons: Buttons_default,
    headerToolbar,
    theme,
    sections,
    $headerToolbar,
    $theme
  });
  $$self.$inject_state = ($$props2) => {
    if ("headerToolbar" in $$props2)
      $$invalidate(2, headerToolbar = $$props2.headerToolbar);
    if ("theme" in $$props2)
      $$invalidate(3, theme = $$props2.theme);
    if ("sections" in $$props2)
      $$invalidate(0, sections = $$props2.sections);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*sections, $headerToolbar*/
    17) {
      $: {
        for (let key of Object.keys(sections)) {
          $$invalidate(0, sections[key] = $headerToolbar[key].split(" ").map((group) => group.split(",")), sections);
        }
      }
    }
  };
  return [sections, $theme, headerToolbar, theme, $headerToolbar];
}
var Toolbar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Toolbar",
      options,
      id: create_fragment2.name
    });
  }
};
var Toolbar_default = Toolbar;

// node_modules/@event-calendar/core/src/Calendar.svelte
var file3 = "node_modules/@event-calendar/core/src/Calendar.svelte";
function create_fragment3(ctx) {
  let div;
  let toolbar;
  let t0;
  let switch_instance0;
  let t1;
  let switch_instance1;
  let div_class_value;
  let current;
  let mounted;
  let dispose;
  toolbar = new Toolbar_default({ $$inline: true });
  var switch_value = (
    /*$_viewComponent*/
    ctx[5]
  );
  function switch_props(ctx2) {
    return { $$inline: true };
  }
  if (switch_value) {
    switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  var switch_value_1 = (
    /*$_interaction*/
    ctx[0].component
  );
  function switch_props_1(ctx2) {
    return { $$inline: true };
  }
  if (switch_value_1) {
    switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx));
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(toolbar.$$.fragment);
      t0 = space();
      if (switch_instance0)
        create_component(switch_instance0.$$.fragment);
      t1 = space();
      if (switch_instance1)
        create_component(switch_instance1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      claim_component(toolbar.$$.fragment, div_nodes);
      t0 = claim_space(div_nodes);
      if (switch_instance0)
        claim_component(switch_instance0.$$.fragment, div_nodes);
      t1 = claim_space(div_nodes);
      if (switch_instance1)
        claim_component(switch_instance1.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].calendar + /*$_viewClass*/
      (ctx[2] ? " " + /*$theme*/
      ctx[1][
        /*$_viewClass*/
        ctx[2]
      ] : "") + /*$_iClass*/
      (ctx[3] ? " " + /*$theme*/
      ctx[1][
        /*$_iClass*/
        ctx[3]
      ] : ""));
      set_style(
        div,
        "height",
        /*$height*/
        ctx[4]
      );
      add_location(div, file3, 124, 0, 3251);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(toolbar, div, null);
      append_hydration_dev(div, t0);
      if (switch_instance0)
        mount_component(switch_instance0, div, null);
      append_hydration_dev(div, t1);
      if (switch_instance1)
        mount_component(switch_instance1, div, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(
          window,
          "click",
          /*handleClick*/
          ctx[16],
          true,
          false,
          false
        );
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (switch_value !== (switch_value = /*$_viewComponent*/
      ctx2[5])) {
        if (switch_instance0) {
          group_outros();
          const old_component = switch_instance0;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance0 = construct_svelte_component_dev(switch_value, switch_props(ctx2));
          create_component(switch_instance0.$$.fragment);
          transition_in(switch_instance0.$$.fragment, 1);
          mount_component(switch_instance0, div, t1);
        } else {
          switch_instance0 = null;
        }
      } else if (switch_value) {
      }
      if (switch_value_1 !== (switch_value_1 = /*$_interaction*/
      ctx2[0].component)) {
        if (switch_instance1) {
          group_outros();
          const old_component = switch_instance1;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value_1) {
          switch_instance1 = construct_svelte_component_dev(switch_value_1, switch_props_1(ctx2));
          create_component(switch_instance1.$$.fragment);
          transition_in(switch_instance1.$$.fragment, 1);
          mount_component(switch_instance1, div, null);
        } else {
          switch_instance1 = null;
        }
      } else if (switch_value_1) {
      }
      if (!current || dirty[0] & /*$theme, $_viewClass, $_iClass*/
      14 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].calendar + /*$_viewClass*/
      (ctx2[2] ? " " + /*$theme*/
      ctx2[1][
        /*$_viewClass*/
        ctx2[2]
      ] : "") + /*$_iClass*/
      (ctx2[3] ? " " + /*$theme*/
      ctx2[1][
        /*$_iClass*/
        ctx2[3]
      ] : ""))) {
        attr_dev(div, "class", div_class_value);
      }
      if (!current || dirty[0] & /*$height*/
      16) {
        set_style(
          div,
          "height",
          /*$height*/
          ctx2[4]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(toolbar.$$.fragment, local);
      if (switch_instance0)
        transition_in(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_in(switch_instance1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(toolbar.$$.fragment, local);
      if (switch_instance0)
        transition_out(switch_instance0.$$.fragment, local);
      if (switch_instance1)
        transition_out(switch_instance1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(toolbar);
      if (switch_instance0)
        destroy_component(switch_instance0);
      if (switch_instance1)
        destroy_component(switch_instance1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $_ignoreClick;
  let $events;
  let $_events;
  let $eventSources;
  let $_interaction;
  let $theme;
  let $_viewClass;
  let $_iClass;
  let $height;
  let $_viewComponent;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Calendar", slots, []);
  let { plugins = [] } = $$props;
  let { options = {} } = $$props;
  let state = new state_default(plugins, options);
  setContext("state", state);
  let { _viewComponent, _viewClass, _ignoreClick, _interaction, _iClass, _events, events: events2, eventSources, height, theme } = state;
  validate_store(_viewComponent, "_viewComponent");
  component_subscribe($$self, _viewComponent, (value) => $$invalidate(5, $_viewComponent = value));
  validate_store(_viewClass, "_viewClass");
  component_subscribe($$self, _viewClass, (value) => $$invalidate(2, $_viewClass = value));
  validate_store(_ignoreClick, "_ignoreClick");
  component_subscribe($$self, _ignoreClick, (value) => $$invalidate(30, $_ignoreClick = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(0, $_interaction = value));
  validate_store(_iClass, "_iClass");
  component_subscribe($$self, _iClass, (value) => $$invalidate(3, $_iClass = value));
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(32, $_events = value));
  validate_store(events2, "events");
  component_subscribe($$self, events2, (value) => $$invalidate(31, $events = value));
  validate_store(eventSources, "eventSources");
  component_subscribe($$self, eventSources, (value) => $$invalidate(33, $eventSources = value));
  validate_store(height, "height");
  component_subscribe($$self, height, (value) => $$invalidate(4, $height = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  function setOption(name, value) {
    if (state.hasOwnProperty(name)) {
      if (state[name].parse) {
        value = state[name].parse(value);
      }
      state[name].set(value);
    }
    return this;
  }
  function getOption(name) {
    let value = state.hasOwnProperty(name) ? get_store_value(state[name]) : void 0;
    return value instanceof Date ? toLocalDate(value) : value;
  }
  function refetchEvents() {
    state._fetchedRange.set({ start: void 0, end: void 0 });
    return this;
  }
  function getEvents() {
    return get_store_value(state._events).map(toEventWithLocalDates);
  }
  function getEventById(id) {
    for (let event of get_store_value(state._events)) {
      if (event.id == id) {
        return toEventWithLocalDates(event);
      }
    }
    return null;
  }
  function addEvent(event) {
    updateEvents((events3) => events3.concat(state.events.parse([event])));
    return this;
  }
  function updateEvent(event) {
    updateEvents((events3) => {
      for (let e of events3) {
        if (e.id == event.id) {
          assign(e, state.events.parse([event])[0]);
          break;
        }
      }
      return events3;
    });
    return this;
  }
  function removeEventById(id) {
    updateEvents((events3) => events3.filter((event) => event.id != id));
    return this;
  }
  function getView() {
    return toViewWithLocalDates(state._view.get());
  }
  function unselect() {
    if ($_interaction.action) {
      $_interaction.action.unselect();
    }
    return this;
  }
  function dateFromPoint(x, y) {
    for (let el of document.elementsFromPoint(x, y)) {
      if (hasFn(el)) {
        let date = runFn(el, y);
        return date ? toLocalDate(date) : null;
      }
    }
    return null;
  }
  function updateEvents(func) {
    if ($eventSources.length) {
      set_store_value(_events, $_events = func($_events), $_events);
    } else {
      set_store_value(events2, $events = func($events), $events);
    }
  }
  function handleClick(jsEvent) {
    if ($_ignoreClick) {
      ignore(jsEvent);
      set_store_value(_ignoreClick, $_ignoreClick = false, $_ignoreClick);
    }
  }
  const writable_props = ["plugins", "options"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Calendar> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(17, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(18, options = $$props2.options);
  };
  $$self.$capture_state = () => ({
    setContext,
    get: get_store_value,
    diff,
    State: state_default,
    Toolbar: Toolbar_default,
    assign,
    toEventWithLocalDates,
    toViewWithLocalDates,
    toLocalDate,
    ignore,
    hasFn,
    runFn,
    plugins,
    options,
    state,
    _viewComponent,
    _viewClass,
    _ignoreClick,
    _interaction,
    _iClass,
    _events,
    events: events2,
    eventSources,
    height,
    theme,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint,
    updateEvents,
    handleClick,
    $_ignoreClick,
    $events,
    $_events,
    $eventSources,
    $_interaction,
    $theme,
    $_viewClass,
    $_iClass,
    $height,
    $_viewComponent
  });
  $$self.$inject_state = ($$props2) => {
    if ("plugins" in $$props2)
      $$invalidate(17, plugins = $$props2.plugins);
    if ("options" in $$props2)
      $$invalidate(18, options = $$props2.options);
    if ("state" in $$props2)
      state = $$props2.state;
    if ("_viewComponent" in $$props2)
      $$invalidate(6, _viewComponent = $$props2._viewComponent);
    if ("_viewClass" in $$props2)
      $$invalidate(7, _viewClass = $$props2._viewClass);
    if ("_ignoreClick" in $$props2)
      $$invalidate(8, _ignoreClick = $$props2._ignoreClick);
    if ("_interaction" in $$props2)
      $$invalidate(9, _interaction = $$props2._interaction);
    if ("_iClass" in $$props2)
      $$invalidate(10, _iClass = $$props2._iClass);
    if ("_events" in $$props2)
      $$invalidate(11, _events = $$props2._events);
    if ("events" in $$props2)
      $$invalidate(12, events2 = $$props2.events);
    if ("eventSources" in $$props2)
      $$invalidate(13, eventSources = $$props2.eventSources);
    if ("height" in $$props2)
      $$invalidate(14, height = $$props2.height);
    if ("theme" in $$props2)
      $$invalidate(15, theme = $$props2.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*options*/
    262144) {
      $:
        for (let [name, value] of diff(options)) {
          setOption(name, value);
        }
    }
  };
  return [
    $_interaction,
    $theme,
    $_viewClass,
    $_iClass,
    $height,
    $_viewComponent,
    _viewComponent,
    _viewClass,
    _ignoreClick,
    _interaction,
    _iClass,
    _events,
    events2,
    eventSources,
    height,
    theme,
    handleClick,
    plugins,
    options,
    setOption,
    getOption,
    refetchEvents,
    getEvents,
    getEventById,
    addEvent,
    updateEvent,
    removeEventById,
    getView,
    unselect,
    dateFromPoint
  ];
}
var Calendar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        plugins: 17,
        options: 18,
        setOption: 19,
        getOption: 20,
        refetchEvents: 21,
        getEvents: 22,
        getEventById: 23,
        addEvent: 24,
        updateEvent: 25,
        removeEventById: 26,
        getView: 27,
        unselect: 28,
        dateFromPoint: 29
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment3.name
    });
  }
  get plugins() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set plugins(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get options() {
    throw new Error("<Calendar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set options(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOption() {
    return this.$$.ctx[19];
  }
  set setOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getOption() {
    return this.$$.ctx[20];
  }
  set getOption(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get refetchEvents() {
    return this.$$.ctx[21];
  }
  set refetchEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEvents() {
    return this.$$.ctx[22];
  }
  set getEvents(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getEventById() {
    return this.$$.ctx[23];
  }
  set getEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get addEvent() {
    return this.$$.ctx[24];
  }
  set addEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateEvent() {
    return this.$$.ctx[25];
  }
  set updateEvent(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get removeEventById() {
    return this.$$.ctx[26];
  }
  set removeEventById(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getView() {
    return this.$$.ctx[27];
  }
  set getView(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get unselect() {
    return this.$$.ctx[28];
  }
  set unselect(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dateFromPoint() {
    return this.$$.ctx[29];
  }
  set dateFromPoint(value) {
    throw new Error("<Calendar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Calendar_default = Calendar;
export {
  Calendar_default as default
};
//# sourceMappingURL=@event-calendar_core.js.map
