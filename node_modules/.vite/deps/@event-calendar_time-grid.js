import {
  DAY_IN_SECONDS,
  addDay,
  addDuration,
  cloneDate,
  createDate,
  createDuration,
  createEventChunk,
  createEventContent,
  datesEqual,
  hasYScroll,
  height,
  maybeIgnore,
  prepareEventChunks,
  rect,
  setContent,
  setFn,
  setMidnight,
  sortEventChunks,
  toEventWithLocalDates,
  toISOString,
  toLocalDate,
  toViewWithLocalDates
} from "./chunk-6RAYDXBS.js";
import {
  derived
} from "./chunk-DY7FSUYH.js";
import "./chunk-6A2TAOKG.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  afterUpdate,
  append_hydration_dev,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  construct_svelte_component_dev,
  createEventDispatcher,
  create_component,
  create_slot,
  destroy_component,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  getContext,
  get_all_dirty_from_scope,
  get_slot_changes,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_data_dev,
  set_store_value,
  set_style,
  space,
  text,
  tick,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_argument,
  validate_each_keys,
  validate_slots,
  validate_store
} from "./chunk-K6MJRMI7.js";

// node_modules/@event-calendar/time-grid/src/stores.js
function times(state, localState) {
  return derived(
    [localState._slotTimeLimits, state._intlSlotLabel, state.slotDuration],
    ([$_slotTimeLimits, $_intlSlotLabel, $slotDuration]) => {
      let compact = $slotDuration.seconds >= 3600;
      let times2 = [];
      let date = createDate("2020-01-01");
      let end = cloneDate(date);
      let i = 1;
      addDuration(date, $_slotTimeLimits.min);
      addDuration(end, $_slotTimeLimits.max);
      while (date < end) {
        times2.push(times2.length && (i || compact) ? $_intlSlotLabel.format(date) : "");
        addDuration(date, $slotDuration);
        i = 1 - i;
      }
      return times2;
    }
  );
}
function slotTimeLimits(state) {
  return derived(
    [state._events, state._viewDates, state.flexibleSlotTimeLimits, state.slotMinTime, state.slotMaxTime],
    ([$_events, $_viewDates, $flexibleSlotTimeLimits, $slotMinTime, $slotMaxTime]) => {
      let min = createDuration($slotMinTime);
      let max = createDuration($slotMaxTime);
      if ($flexibleSlotTimeLimits) {
        let minMin = createDuration(Math.min(min.seconds, Math.max(0, max.seconds - DAY_IN_SECONDS)));
        let maxMax = createDuration(Math.max(max.seconds, minMin.seconds + DAY_IN_SECONDS));
        loop:
          for (let date of $_viewDates) {
            let start = addDuration(cloneDate(date), min);
            let end = addDuration(cloneDate(date), max);
            let minStart = addDuration(cloneDate(date), minMin);
            let maxEnd = addDuration(cloneDate(date), maxMax);
            for (let event of $_events) {
              if (event.display === "auto" && event.start < maxEnd && event.end > minStart) {
                if (event.start < start) {
                  let seconds = Math.max((event.start - date) / 1e3, minMin.seconds);
                  if (seconds < min.seconds) {
                    min.seconds = seconds;
                  }
                }
                if (event.end > end) {
                  let seconds = Math.min((event.end - date) / 1e3, maxMax.seconds);
                  if (seconds > max.seconds) {
                    max.seconds = seconds;
                  }
                }
                if (min.seconds === minMin.seconds && max.seconds === maxMax.seconds) {
                  break loop;
                }
              }
            }
          }
      }
      return { min, max };
    }
  );
}

// node_modules/@event-calendar/time-grid/src/state.js
var state_default = class {
  constructor(state) {
    this._slotTimeLimits = slotTimeLimits(state);
    this._times = times(state, this);
  }
};

// node_modules/@event-calendar/time-grid/src/utils.js
function groupEventChunks(chunks) {
  if (!chunks.length) {
    return;
  }
  sortEventChunks(chunks);
  let group = {
    columns: [],
    end: chunks[0].end
  };
  for (let chunk of chunks) {
    let c = 0;
    if (chunk.start < group.end) {
      for (; c < group.columns.length; ++c) {
        if (group.columns[c][group.columns[c].length - 1].end <= chunk.start) {
          break;
        }
      }
      if (chunk.end > group.end) {
        group.end = chunk.end;
      }
    } else {
      group = {
        columns: [],
        end: chunk.end
      };
    }
    if (group.columns.length < c + 1) {
      group.columns.push([]);
    }
    group.columns[c].push(chunk);
    chunk.group = group;
    chunk.column = c;
  }
}
function createAllDayContent(allDayContent) {
  let text2 = "all-day";
  let content;
  if (allDayContent) {
    content = is_function(allDayContent) ? allDayContent({ text: text2 }) : allDayContent;
    if (typeof content === "string") {
      content = { html: content };
    }
  } else {
    content = {
      html: text2
    };
  }
  return content;
}

// node_modules/@event-calendar/time-grid/src/Header.svelte
var file = "node_modules/@event-calendar/time-grid/src/Header.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div;
  let t_value = (
    /*time*/
    ctx[12] + ""
  );
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[2].time);
      add_location(div, file, 19, 16, 697);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_times*/
      16 && t_value !== (t_value = /*time*/
      ctx2[12] + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme*/
      4 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[2].time)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(19:12) {#each $_times as time}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div6;
  let div2;
  let div0;
  let div0_class_value;
  let setContent_action;
  let t0;
  let div1;
  let div1_class_value;
  let div2_class_value;
  let t1;
  let div4;
  let div3;
  let div3_class_value;
  let t2;
  let div4_class_value;
  let t3;
  let div5;
  let div5_class_value;
  let div6_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*$_times*/
    ctx[4]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  const block = {
    c: function create() {
      div6 = element("div");
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      div4 = element("div");
      div3 = element("div");
      t2 = space();
      if (default_slot)
        default_slot.c();
      t3 = space();
      div5 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div6 = claim_element(nodes, "DIV", { class: true });
      var div6_nodes = children(div6);
      div2 = claim_element(div6_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t1 = claim_space(div6_nodes);
      div4 = claim_element(div6_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      children(div3).forEach(detach_dev);
      t2 = claim_space(div4_nodes);
      if (default_slot)
        default_slot.l(div4_nodes);
      div4_nodes.forEach(detach_dev);
      t3 = claim_space(div6_nodes);
      div5 = claim_element(div6_nodes, "DIV", { class: true });
      children(div5).forEach(detach_dev);
      div6_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[2].sidebarTitle);
      add_location(div0, file, 16, 8, 532);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[2].hiddenTimes);
      add_location(div1, file, 17, 8, 610);
      attr_dev(div2, "class", div2_class_value = /*$theme*/
      ctx[2].sidebar);
      add_location(div2, file, 15, 4, 493);
      attr_dev(div3, "class", div3_class_value = /*$theme*/
      ctx[2].lines);
      add_location(div3, file, 24, 8, 823);
      attr_dev(div4, "class", div4_class_value = /*$theme*/
      ctx[2].days);
      add_location(div4, file, 23, 4, 787);
      attr_dev(div5, "class", div5_class_value = /*$theme*/
      ctx[2].hiddenScroll);
      add_location(div5, file, 27, 4, 895);
      attr_dev(div6, "class", div6_class_value = /*allDay*/
      (ctx[0] ? (
        /*$theme*/
        ctx[2].allDay
      ) : (
        /*$theme*/
        ctx[2].header
      )) + /*$_scrollable*/
      (ctx[3] ? " " + /*$theme*/
      ctx[2].withScroll : ""));
      add_location(div6, file, 14, 0, 389);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div6, anchor);
      append_hydration_dev(div6, div2);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      append_hydration_dev(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append_hydration_dev(div6, t1);
      append_hydration_dev(div6, div4);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div4, t2);
      if (default_slot) {
        default_slot.m(div4, null);
      }
      append_hydration_dev(div6, t3);
      append_hydration_dev(div6, div5);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(setContent_action = setContent.call(
          null,
          div0,
          /*allDayText*/
          ctx[1]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!current || dirty & /*$theme*/
      4 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx2[2].sidebarTitle)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty & /*allDayText*/
      2)
        setContent_action.update.call(
          null,
          /*allDayText*/
          ctx2[1]
        );
      if (dirty & /*$theme, $_times*/
      20) {
        each_value = /*$_times*/
        ctx2[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty & /*$theme*/
      4 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx2[2].hiddenTimes)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*$theme*/
      4 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx2[2].sidebar)) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty & /*$theme*/
      4 && div3_class_value !== (div3_class_value = /*$theme*/
      ctx2[2].lines)) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*$theme*/
      4 && div4_class_value !== (div4_class_value = /*$theme*/
      ctx2[2].days)) {
        attr_dev(div4, "class", div4_class_value);
      }
      if (!current || dirty & /*$theme*/
      4 && div5_class_value !== (div5_class_value = /*$theme*/
      ctx2[2].hiddenScroll)) {
        attr_dev(div5, "class", div5_class_value);
      }
      if (!current || dirty & /*allDay, $theme, $_scrollable*/
      13 && div6_class_value !== (div6_class_value = /*allDay*/
      (ctx2[0] ? (
        /*$theme*/
        ctx2[2].allDay
      ) : (
        /*$theme*/
        ctx2[2].header
      )) + /*$_scrollable*/
      (ctx2[3] ? " " + /*$theme*/
      ctx2[2].withScroll : ""))) {
        attr_dev(div6, "class", div6_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div6);
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $allDayContent;
  let $theme;
  let $_scrollable;
  let $_times;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Header", slots, ["default"]);
  let { allDay = false } = $$props;
  let { _scrollable, allDayContent, theme } = getContext("state");
  validate_store(_scrollable, "_scrollable");
  component_subscribe($$self, _scrollable, (value) => $$invalidate(3, $_scrollable = value));
  validate_store(allDayContent, "allDayContent");
  component_subscribe($$self, allDayContent, (value) => $$invalidate(9, $allDayContent = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(2, $theme = value));
  let { _times } = getContext("view-state");
  validate_store(_times, "_times");
  component_subscribe($$self, _times, (value) => $$invalidate(4, $_times = value));
  let allDayText;
  const writable_props = ["allDay"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Header> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("allDay" in $$props2)
      $$invalidate(0, allDay = $$props2.allDay);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    setContent,
    createAllDayContent,
    allDay,
    _scrollable,
    allDayContent,
    theme,
    _times,
    allDayText,
    $allDayContent,
    $theme,
    $_scrollable,
    $_times
  });
  $$self.$inject_state = ($$props2) => {
    if ("allDay" in $$props2)
      $$invalidate(0, allDay = $$props2.allDay);
    if ("_scrollable" in $$props2)
      $$invalidate(5, _scrollable = $$props2._scrollable);
    if ("allDayContent" in $$props2)
      $$invalidate(6, allDayContent = $$props2.allDayContent);
    if ("theme" in $$props2)
      $$invalidate(7, theme = $$props2.theme);
    if ("_times" in $$props2)
      $$invalidate(8, _times = $$props2._times);
    if ("allDayText" in $$props2)
      $$invalidate(1, allDayText = $$props2.allDayText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$allDayContent*/
    512) {
      $:
        $$invalidate(1, allDayText = createAllDayContent($allDayContent));
    }
  };
  return [
    allDay,
    allDayText,
    $theme,
    $_scrollable,
    $_times,
    _scrollable,
    allDayContent,
    theme,
    _times,
    $allDayContent,
    $$scope,
    slots
  ];
}
var Header = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, { allDay: 0 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Header",
      options,
      id: create_fragment.name
    });
  }
  get allDay() {
    throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set allDay(value) {
    throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Header_default = Header;

// node_modules/@event-calendar/time-grid/src/Body.svelte
var file2 = "node_modules/@event-calendar/time-grid/src/Body.svelte";
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[30] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[33] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let div;
  let t_value = (
    /*time*/
    ctx[33] + ""
  );
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[5].time);
      add_location(div, file2, 46, 16, 1450);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$_times*/
      2 && t_value !== (t_value = /*time*/
      ctx2[33] + ""))
        set_data_dev(t, t_value);
      if (dirty[0] & /*$theme*/
      32 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[5].time)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(46:12) {#each $_times as time}",
    ctx
  });
  return block;
}
function create_each_block2(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[5].line);
      add_location(div, file2, 52, 20, 1660);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$theme*/
      32 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[5].line)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block2.name,
    type: "each",
    source: "(52:16) {#each lines as line}",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div5;
  let div4;
  let div1;
  let div0;
  let div0_class_value;
  let setContent_action;
  let t0;
  let div1_class_value;
  let t1;
  let div3;
  let div2;
  let div2_class_value;
  let t2;
  let div3_class_value;
  let div4_class_value;
  let div5_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = (
    /*$_times*/
    ctx[1]
  );
  validate_each_argument(each_value_1);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = (
    /*lines*/
    ctx[3]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const default_slot_template = (
    /*#slots*/
    ctx[26].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[25],
    null
  );
  const block = {
    c: function create() {
      div5 = element("div");
      div4 = element("div");
      div1 = element("div");
      div0 = element("div");
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      div3 = element("div");
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div5 = claim_element(nodes, "DIV", { class: true });
      var div5_nodes = children(div5);
      div4 = claim_element(div5_nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      div1 = claim_element(div4_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div2_nodes);
      }
      div2_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      if (default_slot)
        default_slot.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      div4_nodes.forEach(detach_dev);
      div5_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[5].sidebarTitle);
      add_location(div0, file2, 44, 12, 1328);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[5].sidebar);
      add_location(div1, file2, 43, 8, 1285);
      attr_dev(div2, "class", div2_class_value = /*$theme*/
      ctx[5].lines);
      add_location(div2, file2, 50, 12, 1573);
      attr_dev(div3, "class", div3_class_value = /*$theme*/
      ctx[5].days);
      add_location(div3, file2, 49, 8, 1533);
      attr_dev(div4, "class", div4_class_value = /*$theme*/
      ctx[5].content);
      add_location(div4, file2, 42, 4, 1246);
      attr_dev(div5, "class", div5_class_value = /*$theme*/
      ctx[5].body + /*compact*/
      (ctx[2] ? " " + /*$theme*/
      ctx[5].compact : ""));
      add_location(div5, file2, 37, 0, 1128);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div5, anchor);
      append_hydration_dev(div5, div4);
      append_hydration_dev(div4, div1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div1, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div1, null);
      }
      append_hydration_dev(div4, t1);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div2, null);
      }
      append_hydration_dev(div3, t2);
      if (default_slot) {
        default_slot.m(div3, null);
      }
      ctx[27](div5);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "resize",
            /*recheckScrollable*/
            ctx[17],
            false,
            false,
            false
          ),
          action_destroyer(setContent_action = setContent.call(
            null,
            div0,
            /*allDayText*/
            ctx[4]
          )),
          listen_dev(
            div5,
            "scroll",
            function() {
              if (is_function(
                /*$_scroll*/
                ctx[6]
              ))
                ctx[6].apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*$theme*/
      32 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[5].sidebarTitle)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*allDayText*/
      16)
        setContent_action.update.call(
          null,
          /*allDayText*/
          ctx[4]
        );
      if (dirty[0] & /*$theme, $_times*/
      34) {
        each_value_1 = /*$_times*/
        ctx[1];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div1, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (!current || dirty[0] & /*$theme*/
      32 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx[5].sidebar)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty[0] & /*$theme, lines*/
      40) {
        each_value = /*lines*/
        ctx[3];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div2, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (!current || dirty[0] & /*$theme*/
      32 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx[5].lines)) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[25],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[25]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[25],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty[0] & /*$theme*/
      32 && div3_class_value !== (div3_class_value = /*$theme*/
      ctx[5].days)) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*$theme*/
      32 && div4_class_value !== (div4_class_value = /*$theme*/
      ctx[5].content)) {
        attr_dev(div4, "class", div4_class_value);
      }
      if (!current || dirty[0] & /*$theme, compact*/
      36 && div5_class_value !== (div5_class_value = /*$theme*/
      ctx[5].body + /*compact*/
      (ctx[2] ? " " + /*$theme*/
      ctx[5].compact : ""))) {
        attr_dev(div5, "class", div5_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div5);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (default_slot)
        default_slot.d(detaching);
      ctx[27](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  let $_scrollable;
  let $slotDuration;
  let $_times;
  let $slotHeight;
  let $scrollTime;
  let $_viewDates;
  let $allDayContent;
  let $_slotTimeLimits;
  let $theme;
  let $_scroll;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Body", slots, ["default"]);
  let { _intlSlotLabel, _viewDates, scrollTime, _scrollable, _scroll, allDayContent, slotDuration, slotHeight, theme } = getContext("state");
  validate_store(_viewDates, "_viewDates");
  component_subscribe($$self, _viewDates, (value) => $$invalidate(22, $_viewDates = value));
  validate_store(scrollTime, "scrollTime");
  component_subscribe($$self, scrollTime, (value) => $$invalidate(21, $scrollTime = value));
  validate_store(_scrollable, "_scrollable");
  component_subscribe($$self, _scrollable, (value) => $$invalidate(28, $_scrollable = value));
  validate_store(_scroll, "_scroll");
  component_subscribe($$self, _scroll, (value) => $$invalidate(6, $_scroll = value));
  validate_store(allDayContent, "allDayContent");
  component_subscribe($$self, allDayContent, (value) => $$invalidate(23, $allDayContent = value));
  validate_store(slotDuration, "slotDuration");
  component_subscribe($$self, slotDuration, (value) => $$invalidate(19, $slotDuration = value));
  validate_store(slotHeight, "slotHeight");
  component_subscribe($$self, slotHeight, (value) => $$invalidate(20, $slotHeight = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(5, $theme = value));
  let { _slotTimeLimits, _times } = getContext("view-state");
  validate_store(_slotTimeLimits, "_slotTimeLimits");
  component_subscribe($$self, _slotTimeLimits, (value) => $$invalidate(24, $_slotTimeLimits = value));
  validate_store(_times, "_times");
  component_subscribe($$self, _times, (value) => $$invalidate(1, $_times = value));
  let el;
  let compact;
  let lines = [];
  let timeLimitMin;
  let allDayText;
  function recheckScrollable() {
    set_store_value(_scrollable, $_scrollable = hasYScroll(el), $_scrollable);
  }
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Body> was created with unknown prop '${key}'`);
  });
  function div5_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el), $$invalidate(22, $_viewDates), $$invalidate(21, $scrollTime), $$invalidate(18, timeLimitMin), $$invalidate(19, $slotDuration), $$invalidate(20, $slotHeight), $$invalidate(1, $_times), $$invalidate(24, $_slotTimeLimits);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("$$scope" in $$props2)
      $$invalidate(25, $$scope = $$props2.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    hasYScroll,
    setContent,
    createAllDayContent,
    _intlSlotLabel,
    _viewDates,
    scrollTime,
    _scrollable,
    _scroll,
    allDayContent,
    slotDuration,
    slotHeight,
    theme,
    _slotTimeLimits,
    _times,
    el,
    compact,
    lines,
    timeLimitMin,
    allDayText,
    recheckScrollable,
    $_scrollable,
    $slotDuration,
    $_times,
    $slotHeight,
    $scrollTime,
    $_viewDates,
    $allDayContent,
    $_slotTimeLimits,
    $theme,
    $_scroll
  });
  $$self.$inject_state = ($$props2) => {
    if ("_intlSlotLabel" in $$props2)
      _intlSlotLabel = $$props2._intlSlotLabel;
    if ("_viewDates" in $$props2)
      $$invalidate(7, _viewDates = $$props2._viewDates);
    if ("scrollTime" in $$props2)
      $$invalidate(8, scrollTime = $$props2.scrollTime);
    if ("_scrollable" in $$props2)
      $$invalidate(9, _scrollable = $$props2._scrollable);
    if ("_scroll" in $$props2)
      $$invalidate(10, _scroll = $$props2._scroll);
    if ("allDayContent" in $$props2)
      $$invalidate(11, allDayContent = $$props2.allDayContent);
    if ("slotDuration" in $$props2)
      $$invalidate(12, slotDuration = $$props2.slotDuration);
    if ("slotHeight" in $$props2)
      $$invalidate(13, slotHeight = $$props2.slotHeight);
    if ("theme" in $$props2)
      $$invalidate(14, theme = $$props2.theme);
    if ("_slotTimeLimits" in $$props2)
      $$invalidate(15, _slotTimeLimits = $$props2._slotTimeLimits);
    if ("_times" in $$props2)
      $$invalidate(16, _times = $$props2._times);
    if ("el" in $$props2)
      $$invalidate(0, el = $$props2.el);
    if ("compact" in $$props2)
      $$invalidate(2, compact = $$props2.compact);
    if ("lines" in $$props2)
      $$invalidate(3, lines = $$props2.lines);
    if ("timeLimitMin" in $$props2)
      $$invalidate(18, timeLimitMin = $$props2.timeLimitMin);
    if ("allDayText" in $$props2)
      $$invalidate(4, allDayText = $$props2.allDayText);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*$slotDuration, $_times, $_slotTimeLimits*/
    17301506) {
      $: {
        $$invalidate(2, compact = $slotDuration.seconds >= 3600);
        $$invalidate(3, lines.length = $_times.length, lines);
        $$invalidate(18, timeLimitMin = $_slotTimeLimits.min.seconds);
      }
    }
    if ($$self.$$.dirty[0] & /*$allDayContent*/
    8388608) {
      $:
        $$invalidate(4, allDayText = createAllDayContent($allDayContent));
    }
    if ($$self.$$.dirty[0] & /*el, $_viewDates, $scrollTime, timeLimitMin, $slotDuration, $slotHeight*/
    8126465) {
      $:
        if (el && $_viewDates) {
          $$invalidate(0, el.scrollTop = (($scrollTime.seconds - timeLimitMin) / $slotDuration.seconds - 0.5) * $slotHeight, el);
        }
    }
    if ($$self.$$.dirty[0] & /*el, $_times, $slotDuration*/
    524291) {
      $:
        if (el && $_times && $slotDuration) {
          setTimeout(recheckScrollable);
        }
    }
  };
  return [
    el,
    $_times,
    compact,
    lines,
    allDayText,
    $theme,
    $_scroll,
    _viewDates,
    scrollTime,
    _scrollable,
    _scroll,
    allDayContent,
    slotDuration,
    slotHeight,
    theme,
    _slotTimeLimits,
    _times,
    recheckScrollable,
    timeLimitMin,
    $slotDuration,
    $slotHeight,
    $scrollTime,
    $_viewDates,
    $allDayContent,
    $_slotTimeLimits,
    $$scope,
    slots,
    div5_binding
  ];
}
var Body = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment2, safe_not_equal, {}, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Body",
      options,
      id: create_fragment2.name
    });
  }
};
var Body_default = Body;

// node_modules/@event-calendar/time-grid/src/Event.svelte
var file3 = "node_modules/@event-calendar/time-grid/src/Event.svelte";
function create_fragment3(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let setContent_action;
  let t;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*$_interaction*/
    ctx[7].resizer
  );
  function switch_props(ctx2) {
    return {
      props: { event: (
        /*event*/
        ctx2[0]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "pointerdown",
      /*createDragHandler*/
      ctx[30](true)
    );
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[2].eventBody);
      add_location(div0, file3, 92, 4, 3246);
      attr_dev(
        div1,
        "class",
        /*classes*/
        ctx[4]
      );
      attr_dev(
        div1,
        "style",
        /*style*/
        ctx[5]
      );
      add_location(div1, file3, 83, 0, 2900);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div1, t);
      if (switch_instance)
        mount_component(switch_instance, div1, null);
      ctx[43](div1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(setContent_action = setContent.call(
            null,
            div0,
            /*content*/
            ctx[6]
          )),
          listen_dev(
            div1,
            "click",
            function() {
              if (is_function(maybeIgnore(
                /*createHandler*/
                ctx[29](
                  /*$eventClick*/
                  ctx[8],
                  /*display*/
                  ctx[1]
                )
              )))
                maybeIgnore(
                  /*createHandler*/
                  ctx[29](
                    /*$eventClick*/
                    ctx[8],
                    /*display*/
                    ctx[1]
                  )
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[29](
                  /*$eventMouseEnter*/
                  ctx[9],
                  /*display*/
                  ctx[1]
                )
              ))
                ctx[29](
                  /*$eventMouseEnter*/
                  ctx[9],
                  /*display*/
                  ctx[1]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[29](
                  /*$eventMouseLeave*/
                  ctx[10],
                  /*display*/
                  ctx[1]
                )
              ))
                ctx[29](
                  /*$eventMouseLeave*/
                  ctx[10],
                  /*display*/
                  ctx[1]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "pointerdown",
            function() {
              if (is_function(
                /*display*/
                ctx[1] === "auto" && /*$_draggable*/
                ctx[11](
                  /*event*/
                  ctx[0]
                ) ? (
                  /*createDragHandler*/
                  ctx[30]()
                ) : void 0
              ))
                /*display*/
                (ctx[1] === "auto" && /*$_draggable*/
                ctx[11](
                  /*event*/
                  ctx[0]
                ) ? (
                  /*createDragHandler*/
                  ctx[30]()
                ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*$theme*/
      4 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[2].eventBody)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/
      64)
        setContent_action.update.call(
          null,
          /*content*/
          ctx[6]
        );
      const switch_instance_changes = {};
      if (dirty[0] & /*event*/
      1)
        switch_instance_changes.event = /*event*/
        ctx[0];
      if (switch_value !== (switch_value = /*$_interaction*/
      ctx[7].resizer)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on(
            "pointerdown",
            /*createDragHandler*/
            ctx[30](true)
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div1, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*classes*/
      16) {
        attr_dev(
          div1,
          "class",
          /*classes*/
          ctx[4]
        );
      }
      if (!current || dirty[0] & /*style*/
      32) {
        attr_dev(
          div1,
          "style",
          /*style*/
          ctx[5]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[43](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  let $_interaction;
  let $_view;
  let $eventDidMount;
  let $_intlEventTime;
  let $theme;
  let $eventContent;
  let $displayEventEnd;
  let $_classes;
  let $eventColor;
  let $eventBackgroundColor;
  let $slotHeight;
  let $_slotTimeLimits;
  let $slotDuration;
  let $eventClick;
  let $eventMouseEnter;
  let $eventMouseLeave;
  let $_draggable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Event", slots, []);
  let { date } = $$props;
  let { chunk } = $$props;
  let { displayEventEnd, eventBackgroundColor, eventColor, eventContent, eventClick, eventDidMount, eventMouseEnter, eventMouseLeave, slotDuration, slotHeight, theme, _view, _intlEventTime, _interaction, _classes, _draggable } = getContext("state");
  validate_store(displayEventEnd, "displayEventEnd");
  component_subscribe($$self, displayEventEnd, (value) => $$invalidate(36, $displayEventEnd = value));
  validate_store(eventBackgroundColor, "eventBackgroundColor");
  component_subscribe($$self, eventBackgroundColor, (value) => $$invalidate(39, $eventBackgroundColor = value));
  validate_store(eventColor, "eventColor");
  component_subscribe($$self, eventColor, (value) => $$invalidate(38, $eventColor = value));
  validate_store(eventContent, "eventContent");
  component_subscribe($$self, eventContent, (value) => $$invalidate(35, $eventContent = value));
  validate_store(eventClick, "eventClick");
  component_subscribe($$self, eventClick, (value) => $$invalidate(8, $eventClick = value));
  validate_store(eventDidMount, "eventDidMount");
  component_subscribe($$self, eventDidMount, (value) => $$invalidate(45, $eventDidMount = value));
  validate_store(eventMouseEnter, "eventMouseEnter");
  component_subscribe($$self, eventMouseEnter, (value) => $$invalidate(9, $eventMouseEnter = value));
  validate_store(eventMouseLeave, "eventMouseLeave");
  component_subscribe($$self, eventMouseLeave, (value) => $$invalidate(10, $eventMouseLeave = value));
  validate_store(slotDuration, "slotDuration");
  component_subscribe($$self, slotDuration, (value) => $$invalidate(42, $slotDuration = value));
  validate_store(slotHeight, "slotHeight");
  component_subscribe($$self, slotHeight, (value) => $$invalidate(40, $slotHeight = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(2, $theme = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(33, $_view = value));
  validate_store(_intlEventTime, "_intlEventTime");
  component_subscribe($$self, _intlEventTime, (value) => $$invalidate(34, $_intlEventTime = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(7, $_interaction = value));
  validate_store(_classes, "_classes");
  component_subscribe($$self, _classes, (value) => $$invalidate(37, $_classes = value));
  validate_store(_draggable, "_draggable");
  component_subscribe($$self, _draggable, (value) => $$invalidate(11, $_draggable = value));
  let { _slotTimeLimits, _viewResources } = getContext("view-state");
  validate_store(_slotTimeLimits, "_slotTimeLimits");
  component_subscribe($$self, _slotTimeLimits, (value) => $$invalidate(41, $_slotTimeLimits = value));
  let el;
  let event;
  let display;
  let classes;
  let style;
  let content;
  let timeText;
  let dragged = false;
  onMount(() => {
    if (is_function($eventDidMount)) {
      $eventDidMount({
        event: toEventWithLocalDates(event),
        timeText,
        el,
        view: toViewWithLocalDates($_view)
      });
    }
  });
  function createHandler(fn, display2) {
    return display2 !== "preview" && is_function(fn) ? (jsEvent) => fn({
      event: toEventWithLocalDates(event),
      el,
      jsEvent,
      view: toViewWithLocalDates($_view)
    }) : void 0;
  }
  function createDragHandler(resize) {
    return (jsEvent) => $_interaction.action.dragTimeGrid(event, el, jsEvent, _viewResources, false, resize);
  }
  $$self.$$.on_mount.push(function() {
    if (date === void 0 && !("date" in $$props || $$self.$$.bound[$$self.$$.props["date"]])) {
      console.warn("<Event> was created without expected prop 'date'");
    }
    if (chunk === void 0 && !("chunk" in $$props || $$self.$$.bound[$$self.$$.props["chunk"]])) {
      console.warn("<Event> was created without expected prop 'chunk'");
    }
  });
  const writable_props = ["date", "chunk"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Event> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(31, date = $$props2.date);
    if ("chunk" in $$props2)
      $$invalidate(32, chunk = $$props2.chunk);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    is_function,
    createEventContent,
    toEventWithLocalDates,
    toViewWithLocalDates,
    setContent,
    maybeIgnore,
    date,
    chunk,
    displayEventEnd,
    eventBackgroundColor,
    eventColor,
    eventContent,
    eventClick,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    slotDuration,
    slotHeight,
    theme,
    _view,
    _intlEventTime,
    _interaction,
    _classes,
    _draggable,
    _slotTimeLimits,
    _viewResources,
    el,
    event,
    display,
    classes,
    style,
    content,
    timeText,
    dragged,
    createHandler,
    createDragHandler,
    $_interaction,
    $_view,
    $eventDidMount,
    $_intlEventTime,
    $theme,
    $eventContent,
    $displayEventEnd,
    $_classes,
    $eventColor,
    $eventBackgroundColor,
    $slotHeight,
    $_slotTimeLimits,
    $slotDuration,
    $eventClick,
    $eventMouseEnter,
    $eventMouseLeave,
    $_draggable
  });
  $$self.$inject_state = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(31, date = $$props2.date);
    if ("chunk" in $$props2)
      $$invalidate(32, chunk = $$props2.chunk);
    if ("displayEventEnd" in $$props2)
      $$invalidate(12, displayEventEnd = $$props2.displayEventEnd);
    if ("eventBackgroundColor" in $$props2)
      $$invalidate(13, eventBackgroundColor = $$props2.eventBackgroundColor);
    if ("eventColor" in $$props2)
      $$invalidate(14, eventColor = $$props2.eventColor);
    if ("eventContent" in $$props2)
      $$invalidate(15, eventContent = $$props2.eventContent);
    if ("eventClick" in $$props2)
      $$invalidate(16, eventClick = $$props2.eventClick);
    if ("eventDidMount" in $$props2)
      $$invalidate(17, eventDidMount = $$props2.eventDidMount);
    if ("eventMouseEnter" in $$props2)
      $$invalidate(18, eventMouseEnter = $$props2.eventMouseEnter);
    if ("eventMouseLeave" in $$props2)
      $$invalidate(19, eventMouseLeave = $$props2.eventMouseLeave);
    if ("slotDuration" in $$props2)
      $$invalidate(20, slotDuration = $$props2.slotDuration);
    if ("slotHeight" in $$props2)
      $$invalidate(21, slotHeight = $$props2.slotHeight);
    if ("theme" in $$props2)
      $$invalidate(22, theme = $$props2.theme);
    if ("_view" in $$props2)
      $$invalidate(23, _view = $$props2._view);
    if ("_intlEventTime" in $$props2)
      $$invalidate(24, _intlEventTime = $$props2._intlEventTime);
    if ("_interaction" in $$props2)
      $$invalidate(25, _interaction = $$props2._interaction);
    if ("_classes" in $$props2)
      $$invalidate(26, _classes = $$props2._classes);
    if ("_draggable" in $$props2)
      $$invalidate(27, _draggable = $$props2._draggable);
    if ("_slotTimeLimits" in $$props2)
      $$invalidate(28, _slotTimeLimits = $$props2._slotTimeLimits);
    if ("_viewResources" in $$props2)
      _viewResources = $$props2._viewResources;
    if ("el" in $$props2)
      $$invalidate(3, el = $$props2.el);
    if ("event" in $$props2)
      $$invalidate(0, event = $$props2.event);
    if ("display" in $$props2)
      $$invalidate(1, display = $$props2.display);
    if ("classes" in $$props2)
      $$invalidate(4, classes = $$props2.classes);
    if ("style" in $$props2)
      $$invalidate(5, style = $$props2.style);
    if ("content" in $$props2)
      $$invalidate(6, content = $$props2.content);
    if ("timeText" in $$props2)
      timeText = $$props2.timeText;
    if ("dragged" in $$props2)
      dragged = $$props2.dragged;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*chunk*/
    2) {
      $:
        $$invalidate(0, event = chunk.event);
    }
    if ($$self.$$.dirty[0] & /*event, style, display, $theme*/
    39 | $$self.$$.dirty[1] & /*$slotDuration, $_slotTimeLimits, chunk, date, $slotHeight, $eventBackgroundColor, $eventColor, $_classes*/
    4035) {
      $: {
        $$invalidate(1, display = event.display);
        let step = $slotDuration.seconds / 60;
        let offset = $_slotTimeLimits.min.seconds / 60;
        let start = (chunk.start - date) / 1e3 / 60;
        let end = (chunk.end - date) / 1e3 / 60;
        let top = (start - offset) / step * $slotHeight;
        let height2 = (end - start) / step * $slotHeight;
        let maxHeight = ($_slotTimeLimits.max.seconds / 60 - start) / step * $slotHeight;
        let bgColor = event.backgroundColor || $eventBackgroundColor || $eventColor;
        $$invalidate(5, style = `top:${top}px;min-height:${height2}px;height:${height2}px;max-height:${maxHeight}px;`);
        if (bgColor) {
          $$invalidate(5, style += `background-color:${bgColor};`);
        }
        if (display === "auto" || display === "ghost") {
          $$invalidate(5, style += `z-index:${chunk.column + 1};left:${100 / chunk.group.columns.length * chunk.column}%;width:${100 / chunk.group.columns.length * 0.5 * (1 + chunk.group.columns.length - chunk.column)}%;`);
        }
        $$invalidate(4, classes = $_classes(display === "background" ? $theme.bgEvent : $theme.event, event));
      }
    }
    if ($$self.$$.dirty[0] & /*$theme*/
    4 | $$self.$$.dirty[1] & /*chunk, $displayEventEnd, $eventContent, $_intlEventTime, $_view*/
    62) {
      $:
        $$invalidate(6, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
    }
  };
  return [
    event,
    display,
    $theme,
    el,
    classes,
    style,
    content,
    $_interaction,
    $eventClick,
    $eventMouseEnter,
    $eventMouseLeave,
    $_draggable,
    displayEventEnd,
    eventBackgroundColor,
    eventColor,
    eventContent,
    eventClick,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    slotDuration,
    slotHeight,
    theme,
    _view,
    _intlEventTime,
    _interaction,
    _classes,
    _draggable,
    _slotTimeLimits,
    createHandler,
    createDragHandler,
    date,
    chunk,
    $_view,
    $_intlEventTime,
    $eventContent,
    $displayEventEnd,
    $_classes,
    $eventColor,
    $eventBackgroundColor,
    $slotHeight,
    $_slotTimeLimits,
    $slotDuration,
    div1_binding
  ];
}
var Event = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment3, safe_not_equal, { date: 31, chunk: 32 }, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Event",
      options,
      id: create_fragment3.name
    });
  }
  get date() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set date(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chunk() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunk(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Event_default = Event;

// node_modules/@event-calendar/time-grid/src/NowIndicator.svelte
var file4 = "node_modules/@event-calendar/time-grid/src/NowIndicator.svelte";
function create_fragment4(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].nowIndicator);
      set_style(
        div,
        "top",
        /*top*/
        ctx[0] + "px"
      );
      add_location(div, file4, 19, 0, 462);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].nowIndicator)) {
        attr_dev(div, "class", div_class_value);
      }
      if (dirty & /*top*/
      1) {
        set_style(
          div,
          "top",
          /*top*/
          ctx2[0] + "px"
        );
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  let $slotHeight;
  let $_slotTimeLimits;
  let $slotDuration;
  let $_today;
  let $_now;
  let $theme;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NowIndicator", slots, []);
  let { slotDuration, slotHeight, theme, _now, _today } = getContext("state");
  validate_store(slotDuration, "slotDuration");
  component_subscribe($$self, slotDuration, (value) => $$invalidate(11, $slotDuration = value));
  validate_store(slotHeight, "slotHeight");
  component_subscribe($$self, slotHeight, (value) => $$invalidate(9, $slotHeight = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  validate_store(_now, "_now");
  component_subscribe($$self, _now, (value) => $$invalidate(13, $_now = value));
  validate_store(_today, "_today");
  component_subscribe($$self, _today, (value) => $$invalidate(12, $_today = value));
  let { _slotTimeLimits } = getContext("view-state");
  validate_store(_slotTimeLimits, "_slotTimeLimits");
  component_subscribe($$self, _slotTimeLimits, (value) => $$invalidate(10, $_slotTimeLimits = value));
  let start;
  let top = 0;
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<NowIndicator> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    slotDuration,
    slotHeight,
    theme,
    _now,
    _today,
    _slotTimeLimits,
    start,
    top,
    $slotHeight,
    $_slotTimeLimits,
    $slotDuration,
    $_today,
    $_now,
    $theme
  });
  $$self.$inject_state = ($$props2) => {
    if ("slotDuration" in $$props2)
      $$invalidate(2, slotDuration = $$props2.slotDuration);
    if ("slotHeight" in $$props2)
      $$invalidate(3, slotHeight = $$props2.slotHeight);
    if ("theme" in $$props2)
      $$invalidate(4, theme = $$props2.theme);
    if ("_now" in $$props2)
      $$invalidate(5, _now = $$props2._now);
    if ("_today" in $$props2)
      $$invalidate(6, _today = $$props2._today);
    if ("_slotTimeLimits" in $$props2)
      $$invalidate(7, _slotTimeLimits = $$props2._slotTimeLimits);
    if ("start" in $$props2)
      $$invalidate(8, start = $$props2.start);
    if ("top" in $$props2)
      $$invalidate(0, top = $$props2.top);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_now, $_today*/
    12288) {
      $:
        $$invalidate(8, start = ($_now - $_today) / 1e3 / 60);
    }
    if ($$self.$$.dirty & /*$slotDuration, $_slotTimeLimits, start, $slotHeight*/
    3840) {
      $: {
        let step = $slotDuration.seconds / 60;
        let offset = $_slotTimeLimits.min.seconds / 60;
        $$invalidate(0, top = (start - offset) / step * $slotHeight);
      }
    }
  };
  return [
    top,
    $theme,
    slotDuration,
    slotHeight,
    theme,
    _now,
    _today,
    _slotTimeLimits,
    start,
    $slotHeight,
    $_slotTimeLimits,
    $slotDuration,
    $_today,
    $_now
  ];
}
var NowIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment4, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NowIndicator",
      options,
      id: create_fragment4.name
    });
  }
};
var NowIndicator_default = NowIndicator;

// node_modules/@event-calendar/time-grid/src/Day.svelte
var file5 = "node_modules/@event-calendar/time-grid/src/Day.svelte";
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[43] = list[i];
  return child_ctx;
}
function create_each_block_12(key_1, ctx) {
  let first;
  let event;
  let current;
  event = new Event_default({
    props: {
      date: (
        /*date*/
        ctx[0]
      ),
      chunk: (
        /*chunk*/
        ctx[43]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(event.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const event_changes = {};
      if (dirty[0] & /*date*/
      1)
        event_changes.date = /*date*/
        ctx[0];
      if (dirty[0] & /*bgChunks*/
      8)
        event_changes.chunk = /*chunk*/
        ctx[43];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_12.name,
    type: "each",
    source: "(120:8) {#each bgChunks as chunk (chunk.event)}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let event;
  let current;
  event = new Event_default({
    props: {
      date: (
        /*date*/
        ctx[0]
      ),
      chunk: (
        /*iChunks*/
        ctx[4][1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(event.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(event.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*date*/
      1)
        event_changes.date = /*date*/
        ctx2[0];
      if (dirty[0] & /*iChunks*/
      16)
        event_changes.chunk = /*iChunks*/
        ctx2[4][1];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(126:8) {#if iChunks[1]}",
    ctx
  });
  return block;
}
function create_each_block3(key_1, ctx) {
  let first;
  let event;
  let current;
  event = new Event_default({
    props: {
      date: (
        /*date*/
        ctx[0]
      ),
      chunk: (
        /*chunk*/
        ctx[43]
      )
    },
    $$inline: true
  });
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      first = empty();
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      claim_component(event.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const event_changes = {};
      if (dirty[0] & /*date*/
      1)
        event_changes.date = /*date*/
        ctx[0];
      if (dirty[0] & /*chunks*/
      4)
        event_changes.chunk = /*chunk*/
        ctx[43];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(first);
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block3.name,
    type: "each",
    source: "(129:8) {#each chunks as chunk (chunk.event)}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let event;
  let current;
  event = new Event_default({
    props: {
      date: (
        /*date*/
        ctx[0]
      ),
      chunk: (
        /*iChunks*/
        ctx[4][0]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(event.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(event.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*date*/
      1)
        event_changes.date = /*date*/
        ctx2[0];
      if (dirty[0] & /*iChunks*/
      16)
        event_changes.chunk = /*iChunks*/
        ctx2[4][0];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(133:8) {#if iChunks[0] && !iChunks[0].event.allDay}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let nowindicator;
  let current;
  nowindicator = new NowIndicator_default({ $$inline: true });
  const block = {
    c: function create() {
      create_component(nowindicator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(nowindicator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(nowindicator, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(nowindicator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(nowindicator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(nowindicator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(139:8) {#if $nowIndicator && isToday}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div3;
  let div0;
  let each_blocks_1 = [];
  let each0_lookup = /* @__PURE__ */ new Map();
  let div0_class_value;
  let t0;
  let div1;
  let t1;
  let each_blocks = [];
  let each1_lookup = /* @__PURE__ */ new Map();
  let t2;
  let div1_class_value;
  let t3;
  let div2;
  let div2_class_value;
  let div3_class_value;
  let current;
  let mounted;
  let dispose;
  let each_value_1 = (
    /*bgChunks*/
    ctx[3]
  );
  validate_each_argument(each_value_1);
  const get_key = (ctx2) => (
    /*chunk*/
    ctx2[43].event
  );
  validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
  for (let i = 0; i < each_value_1.length; i += 1) {
    let child_ctx = get_each_context_12(ctx, each_value_1, i);
    let key = get_key(child_ctx);
    each0_lookup.set(key, each_blocks_1[i] = create_each_block_12(key, child_ctx));
  }
  let if_block0 = (
    /*iChunks*/
    ctx[4][1] && create_if_block_2(ctx)
  );
  let each_value = (
    /*chunks*/
    ctx[2]
  );
  validate_each_argument(each_value);
  const get_key_1 = (ctx2) => (
    /*chunk*/
    ctx2[43].event
  );
  validate_each_keys(ctx, each_value, get_each_context3, get_key_1);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key_1(child_ctx);
    each1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  let if_block1 = (
    /*iChunks*/
    ctx[4][0] && !/*iChunks*/
    ctx[4][0].event.allDay && create_if_block_1(ctx)
  );
  let if_block2 = (
    /*$nowIndicator*/
    ctx[11] && /*isToday*/
    ctx[5] && create_if_block(ctx)
  );
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t0 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      div2 = element("div");
      if (if_block2)
        if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      t2 = claim_space(div1_nodes);
      if (if_block1)
        if_block1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      if (if_block2)
        if_block2.l(div2_nodes);
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[7].bgEvents);
      add_location(div0, file5, 118, 4, 3760);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[7].events);
      add_location(div1, file5, 123, 4, 3907);
      attr_dev(div2, "class", div2_class_value = /*$theme*/
      ctx[7].extra);
      add_location(div2, file5, 136, 4, 4314);
      attr_dev(div3, "class", div3_class_value = /*$theme*/
      ctx[7].day + /*isToday*/
      (ctx[5] ? " " + /*$theme*/
      ctx[7].today : "") + /*highlight*/
      (ctx[6] ? " " + /*$theme*/
      ctx[7].highlight : ""));
      add_location(div3, file5, 110, 0, 3370);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].m(div0, null);
      }
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div1, null);
      }
      append_hydration_dev(div1, t2);
      if (if_block1)
        if_block1.m(div1, null);
      append_hydration_dev(div3, t3);
      append_hydration_dev(div3, div2);
      if (if_block2)
        if_block2.m(div2, null);
      ctx[36](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div3,
            "click",
            function() {
              if (is_function(maybeIgnore(
                /*createClickHandler*/
                ctx[25](
                  /*$dateClick*/
                  ctx[8]
                )
              )))
                maybeIgnore(
                  /*createClickHandler*/
                  ctx[25](
                    /*$dateClick*/
                    ctx[8]
                  )
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "pointerenter",
            function() {
              if (is_function(
                /*createPointerEnterHandler*/
                ctx[26](
                  /*$_interaction*/
                  ctx[9]
                )
              ))
                ctx[26](
                  /*$_interaction*/
                  ctx[9]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "pointerleave",
            function() {
              if (is_function(createPointerLeaveHandler(
                /*$_interaction*/
                ctx[9]
              )))
                createPointerLeaveHandler(
                  /*$_interaction*/
                  ctx[9]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div3,
            "pointerdown",
            function() {
              if (is_function(
                /*createPointerDownHandler*/
                ctx[27](
                  /*$_interaction*/
                  ctx[9],
                  /*$selectable*/
                  ctx[10]
                )
              ))
                ctx[27](
                  /*$_interaction*/
                  ctx[9],
                  /*$selectable*/
                  ctx[10]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*date, bgChunks*/
      9) {
        each_value_1 = /*bgChunks*/
        ctx[3];
        validate_each_argument(each_value_1);
        group_outros();
        validate_each_keys(ctx, each_value_1, get_each_context_12, get_key);
        each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, outro_and_destroy_block, create_each_block_12, null, get_each_context_12);
        check_outros();
      }
      if (!current || dirty[0] & /*$theme*/
      128 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[7].bgEvents)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (
        /*iChunks*/
        ctx[4][1]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*iChunks*/
          16) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*date, chunks*/
      5) {
        each_value = /*chunks*/
        ctx[2];
        validate_each_argument(each_value);
        group_outros();
        validate_each_keys(ctx, each_value, get_each_context3, get_key_1);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div1, outro_and_destroy_block, create_each_block3, t2, get_each_context3);
        check_outros();
      }
      if (
        /*iChunks*/
        ctx[4][0] && !/*iChunks*/
        ctx[4][0].event.allDay
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty[0] & /*iChunks*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$theme*/
      128 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx[7].events)) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (
        /*$nowIndicator*/
        ctx[11] && /*isToday*/
        ctx[5]
      ) {
        if (if_block2) {
          if (dirty[0] & /*$nowIndicator, isToday*/
          2080) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*$theme*/
      128 && div2_class_value !== (div2_class_value = /*$theme*/
      ctx[7].extra)) {
        attr_dev(div2, "class", div2_class_value);
      }
      if (!current || dirty[0] & /*$theme, isToday, highlight*/
      224 && div3_class_value !== (div3_class_value = /*$theme*/
      ctx[7].day + /*isToday*/
      (ctx[5] ? " " + /*$theme*/
      ctx[7].today : "") + /*highlight*/
      (ctx[6] ? " " + /*$theme*/
      ctx[7].highlight : ""))) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      transition_out(if_block0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div3);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].d();
      }
      if (if_block0)
        if_block0.d();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      ctx[36](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function createPointerLeaveHandler(interaction) {
  return interaction.pointer ? interaction.pointer.leave : void 0;
}
function instance5($$self, $$props, $$invalidate) {
  let $_slotTimeLimits;
  let $_view;
  let $slotDuration;
  let $slotHeight;
  let $highlightedDates;
  let $_today;
  let $_iEvents;
  let $_events;
  let $theme;
  let $dateClick;
  let $_interaction;
  let $selectable;
  let $nowIndicator;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Day", slots, []);
  let { date } = $$props;
  let { resource = void 0 } = $$props;
  let { _events, _iEvents, dateClick, highlightedDates, nowIndicator, slotDuration, slotHeight, selectable, theme, _interaction, _today, _view } = getContext("state");
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(35, $_events = value));
  validate_store(_iEvents, "_iEvents");
  component_subscribe($$self, _iEvents, (value) => $$invalidate(34, $_iEvents = value));
  validate_store(dateClick, "dateClick");
  component_subscribe($$self, dateClick, (value) => $$invalidate(8, $dateClick = value));
  validate_store(highlightedDates, "highlightedDates");
  component_subscribe($$self, highlightedDates, (value) => $$invalidate(32, $highlightedDates = value));
  validate_store(nowIndicator, "nowIndicator");
  component_subscribe($$self, nowIndicator, (value) => $$invalidate(11, $nowIndicator = value));
  validate_store(slotDuration, "slotDuration");
  component_subscribe($$self, slotDuration, (value) => $$invalidate(38, $slotDuration = value));
  validate_store(slotHeight, "slotHeight");
  component_subscribe($$self, slotHeight, (value) => $$invalidate(39, $slotHeight = value));
  validate_store(selectable, "selectable");
  component_subscribe($$self, selectable, (value) => $$invalidate(10, $selectable = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(7, $theme = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(9, $_interaction = value));
  validate_store(_today, "_today");
  component_subscribe($$self, _today, (value) => $$invalidate(33, $_today = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(37, $_view = value));
  let { _slotTimeLimits, _viewResources } = getContext("view-state");
  validate_store(_slotTimeLimits, "_slotTimeLimits");
  component_subscribe($$self, _slotTimeLimits, (value) => $$invalidate(31, $_slotTimeLimits = value));
  let el;
  let chunks, bgChunks, iChunks = [];
  let isToday, highlight;
  let start, end;
  function dateFromPoint(y) {
    y -= rect(el).top;
    return addDuration(cloneDate(date), $slotDuration, Math.floor(y / $slotHeight + $_slotTimeLimits.min.seconds / $slotDuration.seconds));
  }
  function createClickHandler(fn) {
    return is_function(fn) ? (jsEvent) => {
      let d = dateFromPoint(jsEvent.clientY);
      fn({
        allDay: false,
        date: toLocalDate(d),
        dateStr: toISOString(d),
        dayEl: el,
        jsEvent,
        view: toViewWithLocalDates($_view),
        resource
      });
    } : void 0;
  }
  function createPointerEnterHandler(interaction) {
    return interaction.pointer ? (jsEvent) => interaction.pointer.enterTimeGrid(date, el, jsEvent, _slotTimeLimits, resource) : void 0;
  }
  function createPointerDownHandler(interaction, selectable2) {
    return selectable2 && interaction.action ? (jsEvent) => interaction.action.selectTimeGrid(date, el, jsEvent, _viewResources, $_slotTimeLimits, false) : void 0;
  }
  function intersects(event) {
    return event.start < end && event.end > start && (resource === void 0 || event.resourceIds.includes(resource.id));
  }
  $$self.$$.on_mount.push(function() {
    if (date === void 0 && !("date" in $$props || $$self.$$.bound[$$self.$$.props["date"]])) {
      console.warn("<Day> was created without expected prop 'date'");
    }
  });
  const writable_props = ["date", "resource"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Day> was created with unknown prop '${key}'`);
  });
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("resource" in $$props2)
      $$invalidate(28, resource = $$props2.resource);
  };
  $$self.$capture_state = () => ({
    getContext,
    is_function,
    cloneDate,
    addDuration,
    toLocalDate,
    datesEqual,
    createEventChunk,
    toViewWithLocalDates,
    rect,
    toISOString,
    maybeIgnore,
    setFn,
    groupEventChunks,
    Event: Event_default,
    NowIndicator: NowIndicator_default,
    date,
    resource,
    _events,
    _iEvents,
    dateClick,
    highlightedDates,
    nowIndicator,
    slotDuration,
    slotHeight,
    selectable,
    theme,
    _interaction,
    _today,
    _view,
    _slotTimeLimits,
    _viewResources,
    el,
    chunks,
    bgChunks,
    iChunks,
    isToday,
    highlight,
    start,
    end,
    dateFromPoint,
    createClickHandler,
    createPointerEnterHandler,
    createPointerLeaveHandler,
    createPointerDownHandler,
    intersects,
    $_slotTimeLimits,
    $_view,
    $slotDuration,
    $slotHeight,
    $highlightedDates,
    $_today,
    $_iEvents,
    $_events,
    $theme,
    $dateClick,
    $_interaction,
    $selectable,
    $nowIndicator
  });
  $$self.$inject_state = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("resource" in $$props2)
      $$invalidate(28, resource = $$props2.resource);
    if ("_events" in $$props2)
      $$invalidate(12, _events = $$props2._events);
    if ("_iEvents" in $$props2)
      $$invalidate(13, _iEvents = $$props2._iEvents);
    if ("dateClick" in $$props2)
      $$invalidate(14, dateClick = $$props2.dateClick);
    if ("highlightedDates" in $$props2)
      $$invalidate(15, highlightedDates = $$props2.highlightedDates);
    if ("nowIndicator" in $$props2)
      $$invalidate(16, nowIndicator = $$props2.nowIndicator);
    if ("slotDuration" in $$props2)
      $$invalidate(17, slotDuration = $$props2.slotDuration);
    if ("slotHeight" in $$props2)
      $$invalidate(18, slotHeight = $$props2.slotHeight);
    if ("selectable" in $$props2)
      $$invalidate(19, selectable = $$props2.selectable);
    if ("theme" in $$props2)
      $$invalidate(20, theme = $$props2.theme);
    if ("_interaction" in $$props2)
      $$invalidate(21, _interaction = $$props2._interaction);
    if ("_today" in $$props2)
      $$invalidate(22, _today = $$props2._today);
    if ("_view" in $$props2)
      $$invalidate(23, _view = $$props2._view);
    if ("_slotTimeLimits" in $$props2)
      $$invalidate(24, _slotTimeLimits = $$props2._slotTimeLimits);
    if ("_viewResources" in $$props2)
      _viewResources = $$props2._viewResources;
    if ("el" in $$props2)
      $$invalidate(1, el = $$props2.el);
    if ("chunks" in $$props2)
      $$invalidate(2, chunks = $$props2.chunks);
    if ("bgChunks" in $$props2)
      $$invalidate(3, bgChunks = $$props2.bgChunks);
    if ("iChunks" in $$props2)
      $$invalidate(4, iChunks = $$props2.iChunks);
    if ("isToday" in $$props2)
      $$invalidate(5, isToday = $$props2.isToday);
    if ("highlight" in $$props2)
      $$invalidate(6, highlight = $$props2.highlight);
    if ("start" in $$props2)
      $$invalidate(29, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(30, end = $$props2.end);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$_slotTimeLimits*/
    1) {
      $: {
        $$invalidate(29, start = addDuration(cloneDate(date), $_slotTimeLimits.min));
        $$invalidate(30, end = addDuration(cloneDate(date), $_slotTimeLimits.max));
      }
    }
    if ($$self.$$.dirty[0] & /*start, end, bgChunks, chunks*/
    1610612748 | $$self.$$.dirty[1] & /*$_events*/
    16) {
      $: {
        $$invalidate(2, chunks = []);
        $$invalidate(3, bgChunks = []);
        for (let event of $_events) {
          if (!event.allDay && intersects(event)) {
            let chunk = createEventChunk(event, start, end);
            switch (event.display) {
              case "background":
                bgChunks.push(chunk);
                break;
              default:
                chunks.push(chunk);
            }
          }
        }
        groupEventChunks(chunks);
      }
    }
    if ($$self.$$.dirty[0] & /*start, end*/
    1610612736 | $$self.$$.dirty[1] & /*$_iEvents*/
    8) {
      $:
        $$invalidate(4, iChunks = $_iEvents.map((event) => event && intersects(event) ? createEventChunk(event, start, end) : null));
    }
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$_today*/
    4) {
      $:
        $$invalidate(5, isToday = datesEqual(date, $_today));
    }
    if ($$self.$$.dirty[0] & /*date*/
    1 | $$self.$$.dirty[1] & /*$highlightedDates*/
    2) {
      $:
        $$invalidate(6, highlight = $highlightedDates.some((d) => datesEqual(d, date)));
    }
    if ($$self.$$.dirty[0] & /*el*/
    2) {
      $:
        if (el) {
          setFn(el, dateFromPoint);
        }
    }
  };
  return [
    date,
    el,
    chunks,
    bgChunks,
    iChunks,
    isToday,
    highlight,
    $theme,
    $dateClick,
    $_interaction,
    $selectable,
    $nowIndicator,
    _events,
    _iEvents,
    dateClick,
    highlightedDates,
    nowIndicator,
    slotDuration,
    slotHeight,
    selectable,
    theme,
    _interaction,
    _today,
    _view,
    _slotTimeLimits,
    createClickHandler,
    createPointerEnterHandler,
    createPointerDownHandler,
    resource,
    start,
    end,
    $_slotTimeLimits,
    $highlightedDates,
    $_today,
    $_iEvents,
    $_events,
    div3_binding
  ];
}
var Day = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment5, safe_not_equal, { date: 0, resource: 28 }, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Day",
      options,
      id: create_fragment5.name
    });
  }
  get date() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set date(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resource() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resource(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Day_default = Day;

// node_modules/@event-calendar/time-grid/src/all-day/Event.svelte
var file6 = "node_modules/@event-calendar/time-grid/src/all-day/Event.svelte";
function create_fragment6(ctx) {
  let div1;
  let div0;
  let div0_class_value;
  let setContent_action;
  let t;
  let switch_instance;
  let current;
  let mounted;
  let dispose;
  var switch_value = (
    /*$_interaction*/
    ctx[7].resizer
  );
  function switch_props(ctx2) {
    return {
      props: { event: (
        /*event*/
        ctx2[0]
      ) },
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    switch_instance.$on(
      "pointerdown",
      /*createDragHandler*/
      ctx[27](true)
    );
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[1].eventBody);
      add_location(div0, file6, 119, 4, 3702);
      attr_dev(
        div1,
        "class",
        /*classes*/
        ctx[3]
      );
      attr_dev(
        div1,
        "style",
        /*style*/
        ctx[4]
      );
      add_location(div1, file6, 110, 0, 3356);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div1, t);
      if (switch_instance)
        mount_component(switch_instance, div1, null);
      ctx[39](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            window,
            "resize",
            /*reposition*/
            ctx[28],
            false,
            false,
            false
          ),
          action_destroyer(setContent_action = setContent.call(
            null,
            div0,
            /*content*/
            ctx[5]
          )),
          listen_dev(
            div1,
            "click",
            function() {
              if (is_function(maybeIgnore(
                /*createHandler*/
                ctx[26](
                  /*$eventClick*/
                  ctx[8],
                  /*display*/
                  ctx[6]
                )
              )))
                maybeIgnore(
                  /*createHandler*/
                  ctx[26](
                    /*$eventClick*/
                    ctx[8],
                    /*display*/
                    ctx[6]
                  )
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseenter",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[26](
                  /*$eventMouseEnter*/
                  ctx[9],
                  /*display*/
                  ctx[6]
                )
              ))
                ctx[26](
                  /*$eventMouseEnter*/
                  ctx[9],
                  /*display*/
                  ctx[6]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mouseleave",
            function() {
              if (is_function(
                /*createHandler*/
                ctx[26](
                  /*$eventMouseLeave*/
                  ctx[10],
                  /*display*/
                  ctx[6]
                )
              ))
                ctx[26](
                  /*$eventMouseLeave*/
                  ctx[10],
                  /*display*/
                  ctx[6]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "pointerdown",
            function() {
              if (is_function(
                /*display*/
                ctx[6] === "auto" && /*$_draggable*/
                ctx[11](
                  /*event*/
                  ctx[0]
                ) ? (
                  /*createDragHandler*/
                  ctx[27]()
                ) : void 0
              ))
                /*display*/
                (ctx[6] === "auto" && /*$_draggable*/
                ctx[11](
                  /*event*/
                  ctx[0]
                ) ? (
                  /*createDragHandler*/
                  ctx[27]()
                ) : void 0).apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*$theme*/
      2 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[1].eventBody)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (setContent_action && is_function(setContent_action.update) && dirty[0] & /*content*/
      32)
        setContent_action.update.call(
          null,
          /*content*/
          ctx[5]
        );
      const switch_instance_changes = {};
      if (dirty[0] & /*event*/
      1)
        switch_instance_changes.event = /*event*/
        ctx[0];
      if (switch_value !== (switch_value = /*$_interaction*/
      ctx[7].resizer)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          switch_instance.$on(
            "pointerdown",
            /*createDragHandler*/
            ctx[27](true)
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, div1, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*classes*/
      8) {
        attr_dev(
          div1,
          "class",
          /*classes*/
          ctx[3]
        );
      }
      if (!current || dirty[0] & /*style*/
      16) {
        attr_dev(
          div1,
          "style",
          /*style*/
          ctx[4]
        );
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (switch_instance)
        destroy_component(switch_instance);
      ctx[39](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance6($$self, $$props, $$invalidate) {
  let $_interaction;
  let $_view;
  let $eventDidMount;
  let $_intlEventTime;
  let $theme;
  let $eventContent;
  let $displayEventEnd;
  let $_classes;
  let $eventColor;
  let $eventBackgroundColor;
  let $eventClick;
  let $eventMouseEnter;
  let $eventMouseLeave;
  let $_draggable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Event", slots, []);
  let { chunk } = $$props;
  let { longChunks = {} } = $$props;
  let { displayEventEnd, eventBackgroundColor, eventClick, eventColor, eventContent, eventDidMount, eventMouseEnter, eventMouseLeave, theme, _view, _intlEventTime, _interaction, _classes, _draggable } = getContext("state");
  validate_store(displayEventEnd, "displayEventEnd");
  component_subscribe($$self, displayEventEnd, (value) => $$invalidate(35, $displayEventEnd = value));
  validate_store(eventBackgroundColor, "eventBackgroundColor");
  component_subscribe($$self, eventBackgroundColor, (value) => $$invalidate(38, $eventBackgroundColor = value));
  validate_store(eventClick, "eventClick");
  component_subscribe($$self, eventClick, (value) => $$invalidate(8, $eventClick = value));
  validate_store(eventColor, "eventColor");
  component_subscribe($$self, eventColor, (value) => $$invalidate(37, $eventColor = value));
  validate_store(eventContent, "eventContent");
  component_subscribe($$self, eventContent, (value) => $$invalidate(34, $eventContent = value));
  validate_store(eventDidMount, "eventDidMount");
  component_subscribe($$self, eventDidMount, (value) => $$invalidate(41, $eventDidMount = value));
  validate_store(eventMouseEnter, "eventMouseEnter");
  component_subscribe($$self, eventMouseEnter, (value) => $$invalidate(9, $eventMouseEnter = value));
  validate_store(eventMouseLeave, "eventMouseLeave");
  component_subscribe($$self, eventMouseLeave, (value) => $$invalidate(10, $eventMouseLeave = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(32, $_view = value));
  validate_store(_intlEventTime, "_intlEventTime");
  component_subscribe($$self, _intlEventTime, (value) => $$invalidate(33, $_intlEventTime = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(7, $_interaction = value));
  validate_store(_classes, "_classes");
  component_subscribe($$self, _classes, (value) => $$invalidate(36, $_classes = value));
  validate_store(_draggable, "_draggable");
  component_subscribe($$self, _draggable, (value) => $$invalidate(11, $_draggable = value));
  let { _viewResources } = getContext("view-state");
  const dispatch = createEventDispatcher();
  let el;
  let event;
  let classes;
  let style;
  let content;
  let timeText;
  let margin = 1;
  let hidden = false;
  let display;
  onMount(() => {
    if (is_function($eventDidMount)) {
      $eventDidMount({
        event: toEventWithLocalDates(event),
        timeText,
        el,
        view: toViewWithLocalDates($_view)
      });
    }
  });
  afterUpdate(reposition);
  function createHandler(fn, display2) {
    return display2 !== "preview" && is_function(fn) ? (jsEvent) => fn({
      event: toEventWithLocalDates(event),
      el,
      jsEvent,
      view: toViewWithLocalDates($_view)
    }) : void 0;
  }
  function createDragHandler(resize) {
    return (jsEvent) => $_interaction.action.dragTimeGrid(event, el, jsEvent, _viewResources, true, resize);
  }
  function reposition() {
    if (!el || display === "preview") {
      return;
    }
    $$invalidate(29, chunk.top = 0, chunk);
    if (chunk.prev) {
      if (chunk.prev.bottom === void 0) {
        tick().then(reposition);
        return;
      }
      $$invalidate(29, chunk.top = chunk.prev.bottom + 1, chunk);
    }
    $$invalidate(29, chunk.bottom = chunk.top + height(el), chunk);
    let m = 1;
    let key = chunk.date.getTime();
    if (longChunks[key]) {
      for (let longChunk of longChunks[key]) {
        if (longChunk.bottom === void 0) {
          tick().then(reposition);
          return;
        }
        if (chunk.top < longChunk.bottom && chunk.bottom > longChunk.top) {
          let offset = longChunk.bottom - chunk.top + 1;
          m += offset;
          $$invalidate(29, chunk.top += offset, chunk);
          $$invalidate(29, chunk.bottom += offset, chunk);
        }
      }
    }
    $$invalidate(31, margin = m);
  }
  $$self.$$.on_mount.push(function() {
    if (chunk === void 0 && !("chunk" in $$props || $$self.$$.bound[$$self.$$.props["chunk"]])) {
      console.warn("<Event> was created without expected prop 'chunk'");
    }
  });
  const writable_props = ["chunk", "longChunks"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Event> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(2, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("chunk" in $$props2)
      $$invalidate(29, chunk = $$props2.chunk);
    if ("longChunks" in $$props2)
      $$invalidate(30, longChunks = $$props2.longChunks);
  };
  $$self.$capture_state = () => ({
    getContext,
    onMount,
    afterUpdate,
    tick,
    createEventDispatcher,
    is_function,
    createEventContent,
    height,
    toEventWithLocalDates,
    toViewWithLocalDates,
    setContent,
    maybeIgnore,
    chunk,
    longChunks,
    displayEventEnd,
    eventBackgroundColor,
    eventClick,
    eventColor,
    eventContent,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    theme,
    _view,
    _intlEventTime,
    _interaction,
    _classes,
    _draggable,
    _viewResources,
    dispatch,
    el,
    event,
    classes,
    style,
    content,
    timeText,
    margin,
    hidden,
    display,
    createHandler,
    createDragHandler,
    reposition,
    $_interaction,
    $_view,
    $eventDidMount,
    $_intlEventTime,
    $theme,
    $eventContent,
    $displayEventEnd,
    $_classes,
    $eventColor,
    $eventBackgroundColor,
    $eventClick,
    $eventMouseEnter,
    $eventMouseLeave,
    $_draggable
  });
  $$self.$inject_state = ($$props2) => {
    if ("chunk" in $$props2)
      $$invalidate(29, chunk = $$props2.chunk);
    if ("longChunks" in $$props2)
      $$invalidate(30, longChunks = $$props2.longChunks);
    if ("displayEventEnd" in $$props2)
      $$invalidate(12, displayEventEnd = $$props2.displayEventEnd);
    if ("eventBackgroundColor" in $$props2)
      $$invalidate(13, eventBackgroundColor = $$props2.eventBackgroundColor);
    if ("eventClick" in $$props2)
      $$invalidate(14, eventClick = $$props2.eventClick);
    if ("eventColor" in $$props2)
      $$invalidate(15, eventColor = $$props2.eventColor);
    if ("eventContent" in $$props2)
      $$invalidate(16, eventContent = $$props2.eventContent);
    if ("eventDidMount" in $$props2)
      $$invalidate(17, eventDidMount = $$props2.eventDidMount);
    if ("eventMouseEnter" in $$props2)
      $$invalidate(18, eventMouseEnter = $$props2.eventMouseEnter);
    if ("eventMouseLeave" in $$props2)
      $$invalidate(19, eventMouseLeave = $$props2.eventMouseLeave);
    if ("theme" in $$props2)
      $$invalidate(20, theme = $$props2.theme);
    if ("_view" in $$props2)
      $$invalidate(21, _view = $$props2._view);
    if ("_intlEventTime" in $$props2)
      $$invalidate(22, _intlEventTime = $$props2._intlEventTime);
    if ("_interaction" in $$props2)
      $$invalidate(23, _interaction = $$props2._interaction);
    if ("_classes" in $$props2)
      $$invalidate(24, _classes = $$props2._classes);
    if ("_draggable" in $$props2)
      $$invalidate(25, _draggable = $$props2._draggable);
    if ("_viewResources" in $$props2)
      _viewResources = $$props2._viewResources;
    if ("el" in $$props2)
      $$invalidate(2, el = $$props2.el);
    if ("event" in $$props2)
      $$invalidate(0, event = $$props2.event);
    if ("classes" in $$props2)
      $$invalidate(3, classes = $$props2.classes);
    if ("style" in $$props2)
      $$invalidate(4, style = $$props2.style);
    if ("content" in $$props2)
      $$invalidate(5, content = $$props2.content);
    if ("timeText" in $$props2)
      timeText = $$props2.timeText;
    if ("margin" in $$props2)
      $$invalidate(31, margin = $$props2.margin);
    if ("hidden" in $$props2)
      hidden = $$props2.hidden;
    if ("display" in $$props2)
      $$invalidate(6, display = $$props2.display);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*chunk*/
    536870912) {
      $:
        $$invalidate(0, event = chunk.event);
    }
    if ($$self.$$.dirty[0] & /*event, chunk, style, $theme*/
    536870931 | $$self.$$.dirty[1] & /*$eventBackgroundColor, $eventColor, margin, $_classes*/
    225) {
      $: {
        $$invalidate(6, display = event.display);
        let bgColor = event.backgroundColor || $eventBackgroundColor || $eventColor;
        $$invalidate(4, style = `width:calc(${chunk.days * 100}% + ${(chunk.days - 1) * 7}px);margin-top:${margin}px;`);
        if (bgColor) {
          $$invalidate(4, style += `background-color:${bgColor};`);
        }
        $$invalidate(3, classes = $_classes($theme.event, event));
      }
    }
    if ($$self.$$.dirty[0] & /*chunk, $theme*/
    536870914 | $$self.$$.dirty[1] & /*$displayEventEnd, $eventContent, $_intlEventTime, $_view*/
    30) {
      $:
        $$invalidate(5, [timeText, content] = createEventContent(chunk, $displayEventEnd, $eventContent, $theme, $_intlEventTime, $_view), content);
    }
  };
  return [
    event,
    $theme,
    el,
    classes,
    style,
    content,
    display,
    $_interaction,
    $eventClick,
    $eventMouseEnter,
    $eventMouseLeave,
    $_draggable,
    displayEventEnd,
    eventBackgroundColor,
    eventClick,
    eventColor,
    eventContent,
    eventDidMount,
    eventMouseEnter,
    eventMouseLeave,
    theme,
    _view,
    _intlEventTime,
    _interaction,
    _classes,
    _draggable,
    createHandler,
    createDragHandler,
    reposition,
    chunk,
    longChunks,
    margin,
    $_view,
    $_intlEventTime,
    $eventContent,
    $displayEventEnd,
    $_classes,
    $eventColor,
    $eventBackgroundColor,
    div1_binding
  ];
}
var Event2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance6, create_fragment6, safe_not_equal, { chunk: 29, longChunks: 30 }, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Event",
      options,
      id: create_fragment6.name
    });
  }
  get chunk() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunk(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get longChunks() {
    throw new Error("<Event>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set longChunks(value) {
    throw new Error("<Event>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Event_default2 = Event2;

// node_modules/@event-calendar/time-grid/src/all-day/Day.svelte
var file7 = "node_modules/@event-calendar/time-grid/src/all-day/Day.svelte";
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div;
  let event;
  let div_class_value;
  let current;
  event = new Event_default2({
    props: { chunk: (
      /*iChunks*/
      ctx[2][0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(event.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      claim_component(event.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[7].events + " " + /*$theme*/
      ctx[7].preview);
      add_location(div, file7, 80, 8, 2277);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(event, div, null);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*iChunks*/
      4)
        event_changes.chunk = /*iChunks*/
        ctx2[2][0];
      event.$set(event_changes);
      if (!current || dirty[0] & /*$theme*/
      128 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[7].events + " " + /*$theme*/
      ctx2[7].preview)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
      destroy_component(event);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(80:4) {#if iChunks[0] && datesEqual(iChunks[0].date, date)}",
    ctx
  });
  return block;
}
function create_each_block4(ctx) {
  let event;
  let current;
  event = new Event_default2({
    props: {
      chunk: (
        /*chunk*/
        ctx[29]
      ),
      longChunks: (
        /*longChunks*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(event.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(event.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(event, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const event_changes = {};
      if (dirty[0] & /*dayChunks*/
      16)
        event_changes.chunk = /*chunk*/
        ctx2[29];
      if (dirty[0] & /*longChunks*/
      2)
        event_changes.longChunks = /*longChunks*/
        ctx2[1];
      event.$set(event_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(event.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(event.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(event, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block4.name,
    type: "each",
    source: "(86:8) {#each dayChunks as chunk}",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div1;
  let show_if = (
    /*iChunks*/
    ctx[2][0] && datesEqual(
      /*iChunks*/
      ctx[2][0].date,
      /*date*/
      ctx[0]
    )
  );
  let t;
  let div0;
  let div0_class_value;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  let if_block = show_if && create_if_block2(ctx);
  let each_value = (
    /*dayChunks*/
    ctx[4]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div0_nodes);
      }
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", div0_class_value = /*$theme*/
      ctx[7].events);
      add_location(div0, file7, 84, 4, 2393);
      attr_dev(div1, "class", div1_class_value = /*$theme*/
      ctx[7].day + /*isToday*/
      (ctx[5] ? " " + /*$theme*/
      ctx[7].today : "") + /*highlight*/
      (ctx[6] ? " " + /*$theme*/
      ctx[7].highlight : ""));
      add_location(div1, file7, 72, 0, 1916);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(div0, null);
      }
      ctx[23](div1);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            div1,
            "click",
            function() {
              if (is_function(maybeIgnore(
                /*createClickHandler*/
                ctx[18](
                  /*$dateClick*/
                  ctx[8]
                )
              )))
                maybeIgnore(
                  /*createClickHandler*/
                  ctx[18](
                    /*$dateClick*/
                    ctx[8]
                  )
                ).apply(this, arguments);
            },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "pointerdown",
            function() {
              if (is_function(
                /*createPointerDownHandler*/
                ctx[19](
                  /*$_interaction*/
                  ctx[9],
                  /*$selectable*/
                  ctx[10]
                )
              ))
                ctx[19](
                  /*$_interaction*/
                  ctx[9],
                  /*$selectable*/
                  ctx[10]
                ).apply(this, arguments);
            },
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*iChunks, date*/
      5)
        show_if = /*iChunks*/
        ctx[2][0] && datesEqual(
          /*iChunks*/
          ctx[2][0].date,
          /*date*/
          ctx[0]
        );
      if (show_if) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*iChunks, date*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & /*dayChunks, longChunks*/
      18) {
        each_value = /*dayChunks*/
        ctx[4];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (!current || dirty[0] & /*$theme*/
      128 && div0_class_value !== (div0_class_value = /*$theme*/
      ctx[7].events)) {
        attr_dev(div0, "class", div0_class_value);
      }
      if (!current || dirty[0] & /*$theme, isToday, highlight*/
      224 && div1_class_value !== (div1_class_value = /*$theme*/
      ctx[7].day + /*isToday*/
      (ctx[5] ? " " + /*$theme*/
      ctx[7].today : "") + /*highlight*/
      (ctx[6] ? " " + /*$theme*/
      ctx[7].highlight : ""))) {
        attr_dev(div1, "class", div1_class_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div1);
      if (if_block)
        if_block.d();
      destroy_each(each_blocks, detaching);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance7($$self, $$props, $$invalidate) {
  let $_slotTimeLimits;
  let $_view;
  let $highlightedDates;
  let $theme;
  let $dateClick;
  let $_interaction;
  let $selectable;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Day", slots, []);
  let { date } = $$props;
  let { chunks } = $$props;
  let { longChunks } = $$props;
  let { iChunks = [] } = $$props;
  let { resource = void 0 } = $$props;
  let { date: currentDate, dateClick, highlightedDates, theme, _view, _interaction, selectable } = getContext("state");
  validate_store(dateClick, "dateClick");
  component_subscribe($$self, dateClick, (value) => $$invalidate(8, $dateClick = value));
  validate_store(highlightedDates, "highlightedDates");
  component_subscribe($$self, highlightedDates, (value) => $$invalidate(22, $highlightedDates = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(7, $theme = value));
  validate_store(_view, "_view");
  component_subscribe($$self, _view, (value) => $$invalidate(25, $_view = value));
  validate_store(_interaction, "_interaction");
  component_subscribe($$self, _interaction, (value) => $$invalidate(9, $_interaction = value));
  validate_store(selectable, "selectable");
  component_subscribe($$self, selectable, (value) => $$invalidate(10, $selectable = value));
  let { _slotTimeLimits, _viewResources } = getContext("view-state");
  validate_store(_slotTimeLimits, "_slotTimeLimits");
  component_subscribe($$self, _slotTimeLimits, (value) => $$invalidate(24, $_slotTimeLimits = value));
  let el;
  let dayChunks;
  let today = setMidnight(createDate());
  let isToday;
  let highlight;
  function createClickHandler(fn) {
    return is_function(fn) ? (jsEvent) => {
      fn({
        allDay: true,
        date: toLocalDate(date),
        dateStr: toISOString(date),
        dayEl: el,
        jsEvent,
        view: toViewWithLocalDates($_view),
        resource
      });
    } : void 0;
  }
  function createPointerDownHandler(interaction, selectable2) {
    return selectable2 && interaction.action ? (jsEvent) => interaction.action.selectTimeGrid(date, el, jsEvent, _viewResources, $_slotTimeLimits, true) : void 0;
  }
  $$self.$$.on_mount.push(function() {
    if (date === void 0 && !("date" in $$props || $$self.$$.bound[$$self.$$.props["date"]])) {
      console.warn("<Day> was created without expected prop 'date'");
    }
    if (chunks === void 0 && !("chunks" in $$props || $$self.$$.bound[$$self.$$.props["chunks"]])) {
      console.warn("<Day> was created without expected prop 'chunks'");
    }
    if (longChunks === void 0 && !("longChunks" in $$props || $$self.$$.bound[$$self.$$.props["longChunks"]])) {
      console.warn("<Day> was created without expected prop 'longChunks'");
    }
  });
  const writable_props = ["date", "chunks", "longChunks", "iChunks", "resource"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Day> was created with unknown prop '${key}'`);
  });
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(3, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("chunks" in $$props2)
      $$invalidate(20, chunks = $$props2.chunks);
    if ("longChunks" in $$props2)
      $$invalidate(1, longChunks = $$props2.longChunks);
    if ("iChunks" in $$props2)
      $$invalidate(2, iChunks = $$props2.iChunks);
    if ("resource" in $$props2)
      $$invalidate(21, resource = $$props2.resource);
  };
  $$self.$capture_state = () => ({
    getContext,
    is_function,
    createDate,
    setMidnight,
    toLocalDate,
    datesEqual,
    toViewWithLocalDates,
    toISOString,
    maybeIgnore,
    setFn,
    Event: Event_default2,
    date,
    chunks,
    longChunks,
    iChunks,
    resource,
    currentDate,
    dateClick,
    highlightedDates,
    theme,
    _view,
    _interaction,
    selectable,
    _slotTimeLimits,
    _viewResources,
    el,
    dayChunks,
    today,
    isToday,
    highlight,
    createClickHandler,
    createPointerDownHandler,
    $_slotTimeLimits,
    $_view,
    $highlightedDates,
    $theme,
    $dateClick,
    $_interaction,
    $selectable
  });
  $$self.$inject_state = ($$props2) => {
    if ("date" in $$props2)
      $$invalidate(0, date = $$props2.date);
    if ("chunks" in $$props2)
      $$invalidate(20, chunks = $$props2.chunks);
    if ("longChunks" in $$props2)
      $$invalidate(1, longChunks = $$props2.longChunks);
    if ("iChunks" in $$props2)
      $$invalidate(2, iChunks = $$props2.iChunks);
    if ("resource" in $$props2)
      $$invalidate(21, resource = $$props2.resource);
    if ("currentDate" in $$props2)
      currentDate = $$props2.currentDate;
    if ("dateClick" in $$props2)
      $$invalidate(11, dateClick = $$props2.dateClick);
    if ("highlightedDates" in $$props2)
      $$invalidate(12, highlightedDates = $$props2.highlightedDates);
    if ("theme" in $$props2)
      $$invalidate(13, theme = $$props2.theme);
    if ("_view" in $$props2)
      $$invalidate(14, _view = $$props2._view);
    if ("_interaction" in $$props2)
      $$invalidate(15, _interaction = $$props2._interaction);
    if ("selectable" in $$props2)
      $$invalidate(16, selectable = $$props2.selectable);
    if ("_slotTimeLimits" in $$props2)
      $$invalidate(17, _slotTimeLimits = $$props2._slotTimeLimits);
    if ("_viewResources" in $$props2)
      _viewResources = $$props2._viewResources;
    if ("el" in $$props2)
      $$invalidate(3, el = $$props2.el);
    if ("dayChunks" in $$props2)
      $$invalidate(4, dayChunks = $$props2.dayChunks);
    if ("today" in $$props2)
      $$invalidate(28, today = $$props2.today);
    if ("isToday" in $$props2)
      $$invalidate(5, isToday = $$props2.isToday);
    if ("highlight" in $$props2)
      $$invalidate(6, highlight = $$props2.highlight);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*chunks, date, dayChunks*/
    1048593) {
      $: {
        $$invalidate(4, dayChunks = []);
        for (let chunk of chunks) {
          if (datesEqual(chunk.date, date)) {
            dayChunks.push(chunk);
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*date, $highlightedDates*/
    4194305) {
      $: {
        $$invalidate(5, isToday = datesEqual(date, today));
        $$invalidate(6, highlight = $highlightedDates.some((d) => datesEqual(d, date)));
      }
    }
    if ($$self.$$.dirty[0] & /*el, date*/
    9) {
      $:
        if (el) {
          setFn(el, () => date);
        }
    }
  };
  return [
    date,
    longChunks,
    iChunks,
    el,
    dayChunks,
    isToday,
    highlight,
    $theme,
    $dateClick,
    $_interaction,
    $selectable,
    dateClick,
    highlightedDates,
    theme,
    _view,
    _interaction,
    selectable,
    _slotTimeLimits,
    createClickHandler,
    createPointerDownHandler,
    chunks,
    resource,
    $highlightedDates,
    div1_binding
  ];
}
var Day2 = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance7,
      create_fragment7,
      safe_not_equal,
      {
        date: 0,
        chunks: 20,
        longChunks: 1,
        iChunks: 2,
        resource: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Day",
      options,
      id: create_fragment7.name
    });
  }
  get date() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set date(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get chunks() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set chunks(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get longChunks() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set longChunks(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iChunks() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iChunks(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resource() {
    throw new Error("<Day>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resource(value) {
    throw new Error("<Day>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Day_default2 = Day2;

// node_modules/@event-calendar/time-grid/src/all-day/Week.svelte
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i];
  return child_ctx;
}
function create_each_block5(ctx) {
  let day;
  let current;
  day = new Day_default2({
    props: {
      date: (
        /*date*/
        ctx[15]
      ),
      chunks: (
        /*chunks*/
        ctx[2]
      ),
      longChunks: (
        /*longChunks*/
        ctx[3]
      ),
      iChunks: (
        /*iChunks*/
        ctx[4]
      ),
      resource: (
        /*resource*/
        ctx[1]
      )
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(day.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(day.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(day, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const day_changes = {};
      if (dirty & /*dates*/
      1)
        day_changes.date = /*date*/
        ctx2[15];
      if (dirty & /*chunks*/
      4)
        day_changes.chunks = /*chunks*/
        ctx2[2];
      if (dirty & /*longChunks*/
      8)
        day_changes.longChunks = /*longChunks*/
        ctx2[3];
      if (dirty & /*iChunks*/
      16)
        day_changes.iChunks = /*iChunks*/
        ctx2[4];
      if (dirty & /*resource*/
      2)
        day_changes.resource = /*resource*/
        ctx2[1];
      day.$set(day_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(day.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(day.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(day, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block5.name,
    type: "each",
    source: "(49:0) {#each dates as date}",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*dates*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*dates, chunks, longChunks, iChunks, resource*/
      31) {
        each_value = /*dates*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance8($$self, $$props, $$invalidate) {
  let $hiddenDays;
  let $_iEvents;
  let $_events;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Week", slots, []);
  let { dates } = $$props;
  let { resource = void 0 } = $$props;
  let { _events, _iEvents, hiddenDays, theme } = getContext("state");
  validate_store(_events, "_events");
  component_subscribe($$self, _events, (value) => $$invalidate(12, $_events = value));
  validate_store(_iEvents, "_iEvents");
  component_subscribe($$self, _iEvents, (value) => $$invalidate(11, $_iEvents = value));
  validate_store(hiddenDays, "hiddenDays");
  component_subscribe($$self, hiddenDays, (value) => $$invalidate(10, $hiddenDays = value));
  let chunks, longChunks, iChunks = [];
  let start;
  let end;
  function intersects(event) {
    return event.start < end && event.end > start && (resource === void 0 || event.resourceIds.includes(resource.id));
  }
  $$self.$$.on_mount.push(function() {
    if (dates === void 0 && !("dates" in $$props || $$self.$$.bound[$$self.$$.props["dates"]])) {
      console.warn("<Week> was created without expected prop 'dates'");
    }
  });
  const writable_props = ["dates", "resource"];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<Week> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("dates" in $$props2)
      $$invalidate(0, dates = $$props2.dates);
    if ("resource" in $$props2)
      $$invalidate(1, resource = $$props2.resource);
  };
  $$self.$capture_state = () => ({
    getContext,
    cloneDate,
    addDay,
    createEventChunk,
    prepareEventChunks,
    Day: Day_default2,
    dates,
    resource,
    _events,
    _iEvents,
    hiddenDays,
    theme,
    chunks,
    longChunks,
    iChunks,
    start,
    end,
    intersects,
    $hiddenDays,
    $_iEvents,
    $_events
  });
  $$self.$inject_state = ($$props2) => {
    if ("dates" in $$props2)
      $$invalidate(0, dates = $$props2.dates);
    if ("resource" in $$props2)
      $$invalidate(1, resource = $$props2.resource);
    if ("_events" in $$props2)
      $$invalidate(5, _events = $$props2._events);
    if ("_iEvents" in $$props2)
      $$invalidate(6, _iEvents = $$props2._iEvents);
    if ("hiddenDays" in $$props2)
      $$invalidate(7, hiddenDays = $$props2.hiddenDays);
    if ("theme" in $$props2)
      theme = $$props2.theme;
    if ("chunks" in $$props2)
      $$invalidate(2, chunks = $$props2.chunks);
    if ("longChunks" in $$props2)
      $$invalidate(3, longChunks = $$props2.longChunks);
    if ("iChunks" in $$props2)
      $$invalidate(4, iChunks = $$props2.iChunks);
    if ("start" in $$props2)
      $$invalidate(8, start = $$props2.start);
    if ("end" in $$props2)
      $$invalidate(9, end = $$props2.end);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*dates*/
    1) {
      $: {
        $$invalidate(8, start = dates[0]);
        $$invalidate(9, end = addDay(cloneDate(dates[dates.length - 1])));
      }
    }
    if ($$self.$$.dirty & /*$_events, start, end, chunks, $hiddenDays*/
    5892) {
      $: {
        $$invalidate(2, chunks = []);
        for (let event of $_events) {
          if (event.allDay && event.display !== "background" && intersects(event)) {
            let chunk = createEventChunk(event, start, end);
            chunks.push(chunk);
          }
        }
        $$invalidate(3, longChunks = prepareEventChunks(chunks, $hiddenDays));
      }
    }
    if ($$self.$$.dirty & /*$_iEvents, start, end, $hiddenDays*/
    3840) {
      $:
        $$invalidate(4, iChunks = $_iEvents.map((event) => {
          let chunk;
          if (event && event.allDay && intersects(event)) {
            chunk = createEventChunk(event, start, end);
            prepareEventChunks([chunk], $hiddenDays);
          } else {
            chunk = null;
          }
          return chunk;
        }));
    }
  };
  return [
    dates,
    resource,
    chunks,
    longChunks,
    iChunks,
    _events,
    _iEvents,
    hiddenDays,
    start,
    end,
    $hiddenDays,
    $_iEvents,
    $_events
  ];
}
var Week = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance8, create_fragment8, safe_not_equal, { dates: 0, resource: 1 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Week",
      options,
      id: create_fragment8.name
    });
  }
  get dates() {
    throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dates(value) {
    throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get resource() {
    throw new Error("<Week>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set resource(value) {
    throw new Error("<Week>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Week_default = Week;

// node_modules/@event-calendar/time-grid/src/View.svelte
var file8 = "node_modules/@event-calendar/time-grid/src/View.svelte";
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block_13(ctx) {
  let div;
  let t_value = (
    /*$_intlDayHeader*/
    ctx[2].format(
      /*date*/
      ctx[11]
    ) + ""
  );
  let t;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      t = claim_text(div_nodes, t_value);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*$theme*/
      ctx[1].day);
      add_location(div, file8, 18, 8, 506);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_intlDayHeader, $_viewDates*/
      5 && t_value !== (t_value = /*$_intlDayHeader*/
      ctx2[2].format(
        /*date*/
        ctx2[11]
      ) + ""))
        set_data_dev(t, t_value);
      if (dirty & /*$theme*/
      2 && div_class_value !== (div_class_value = /*$theme*/
      ctx2[1].day)) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching)
        detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_13.name,
    type: "each",
    source: "(18:4) {#each $_viewDates as date}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let each_1_anchor;
  let each_value_1 = (
    /*$_viewDates*/
    ctx[0]
  );
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$theme, $_intlDayHeader, $_viewDates*/
      7) {
        each_value_1 = /*$_viewDates*/
        ctx2[0];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(17:0) <Header>",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let header;
  let current;
  header = new Header_default({
    props: {
      allDay: true,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(header.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(header.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(header, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*$$scope, $_viewDates*/
      65537) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header.$set(header_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(header, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(22:0) {#if $allDaySlot}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let week;
  let current;
  week = new Week_default({
    props: { dates: (
      /*$_viewDates*/
      ctx[0]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(week.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(week.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(week, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const week_changes = {};
      if (dirty & /*$_viewDates*/
      1)
        week_changes.dates = /*$_viewDates*/
        ctx2[0];
      week.$set(week_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(week.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(week.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(week, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(23:4) <Header allDay>",
    ctx
  });
  return block;
}
function create_each_block6(ctx) {
  let day;
  let current;
  day = new Day_default({
    props: { date: (
      /*date*/
      ctx[11]
    ) },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(day.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(day.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(day, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const day_changes = {};
      if (dirty & /*$_viewDates*/
      1)
        day_changes.date = /*date*/
        ctx2[11];
      day.$set(day_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(day.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(day.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(day, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block6.name,
    type: "each",
    source: "(28:0) {#each $_viewDates as date}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let each_1_anchor;
  let current;
  let each_value = (
    /*$_viewDates*/
    ctx[0]
  );
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(target, anchor);
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*$_viewDates*/
      1) {
        each_value = /*$_viewDates*/
        ctx2[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(27:0) <Body>",
    ctx
  });
  return block;
}
function create_fragment9(ctx) {
  let header;
  let t0;
  let t1;
  let body;
  let current;
  header = new Header_default({
    props: {
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  let if_block = (
    /*$allDaySlot*/
    ctx[3] && create_if_block3(ctx)
  );
  body = new Body_default({
    props: {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(header.$$.fragment);
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      create_component(body.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(header.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (if_block)
        if_block.l(nodes);
      t1 = claim_space(nodes);
      claim_component(body.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(header, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(body, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const header_changes = {};
      if (dirty & /*$$scope, $_viewDates, $theme, $_intlDayHeader*/
      65543) {
        header_changes.$$scope = { dirty, ctx: ctx2 };
      }
      header.$set(header_changes);
      if (
        /*$allDaySlot*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$allDaySlot*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t1.parentNode, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      const body_changes = {};
      if (dirty & /*$$scope, $_viewDates*/
      65537) {
        body_changes.$$scope = { dirty, ctx: ctx2 };
      }
      body.$set(body_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      transition_in(body.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      transition_out(body.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(header, detaching);
      if (detaching)
        detach_dev(t0);
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach_dev(t1);
      destroy_component(body, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance9($$self, $$props, $$invalidate) {
  let $_viewClass;
  let $_viewDates;
  let $theme;
  let $_intlDayHeader;
  let $allDaySlot;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("View", slots, []);
  let state = getContext("state");
  let { _viewDates, _intlDayHeader, _viewClass, allDaySlot, theme } = state;
  validate_store(_viewDates, "_viewDates");
  component_subscribe($$self, _viewDates, (value) => $$invalidate(0, $_viewDates = value));
  validate_store(_intlDayHeader, "_intlDayHeader");
  component_subscribe($$self, _intlDayHeader, (value) => $$invalidate(2, $_intlDayHeader = value));
  validate_store(_viewClass, "_viewClass");
  component_subscribe($$self, _viewClass, (value) => $$invalidate(9, $_viewClass = value));
  validate_store(allDaySlot, "allDaySlot");
  component_subscribe($$self, allDaySlot, (value) => $$invalidate(3, $allDaySlot = value));
  validate_store(theme, "theme");
  component_subscribe($$self, theme, (value) => $$invalidate(1, $theme = value));
  setContext("view-state", new state_default(state));
  set_store_value(_viewClass, $_viewClass = "week", $_viewClass);
  const writable_props = [];
  Object.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<View> was created with unknown prop '${key}'`);
  });
  $$self.$capture_state = () => ({
    getContext,
    setContext,
    State: state_default,
    Header: Header_default,
    Body: Body_default,
    Day: Day_default,
    Week: Week_default,
    state,
    _viewDates,
    _intlDayHeader,
    _viewClass,
    allDaySlot,
    theme,
    $_viewClass,
    $_viewDates,
    $theme,
    $_intlDayHeader,
    $allDaySlot
  });
  $$self.$inject_state = ($$props2) => {
    if ("state" in $$props2)
      state = $$props2.state;
    if ("_viewDates" in $$props2)
      $$invalidate(4, _viewDates = $$props2._viewDates);
    if ("_intlDayHeader" in $$props2)
      $$invalidate(5, _intlDayHeader = $$props2._intlDayHeader);
    if ("_viewClass" in $$props2)
      $$invalidate(6, _viewClass = $$props2._viewClass);
    if ("allDaySlot" in $$props2)
      $$invalidate(7, allDaySlot = $$props2.allDaySlot);
    if ("theme" in $$props2)
      $$invalidate(8, theme = $$props2.theme);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    $_viewDates,
    $theme,
    $_intlDayHeader,
    $allDaySlot,
    _viewDates,
    _intlDayHeader,
    _viewClass,
    allDaySlot,
    theme
  ];
}
var View = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance9, create_fragment9, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "View",
      options,
      id: create_fragment9.name
    });
  }
};
var View_default = View;

// node_modules/@event-calendar/time-grid/src/index.js
var src_default = {
  createOptions(options) {
    options.buttonText.timeGridDay = "day";
    options.buttonText.timeGridWeek = "week";
    options.view = "timeGridWeek";
    options.views.timeGridDay = {
      component: View_default,
      dayHeaderFormat: { weekday: "long" },
      duration: { days: 1 },
      titleFormat: { year: "numeric", month: "long", day: "numeric" }
    };
    options.views.timeGridWeek = {
      component: View_default,
      duration: { weeks: 1 }
    };
  }
};
export {
  Body_default as Body,
  Day_default as Day,
  Header_default as Header,
  state_default as State,
  Week_default as Week,
  src_default as default
};
//# sourceMappingURL=@event-calendar_time-grid.js.map
