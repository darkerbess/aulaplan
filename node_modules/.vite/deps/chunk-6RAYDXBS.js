import {
  derived,
  writable
} from "./chunk-DY7FSUYH.js";
import {
  get_store_value,
  is_function
} from "./chunk-K6MJRMI7.js";

// node_modules/@event-calendar/common/src/date.js
var DAY_IN_SECONDS = 86400;
function createDate(input) {
  if (input !== void 0) {
    return input instanceof Date ? _fromLocalDate(input) : _fromISOString(input);
  }
  return _fromLocalDate(new Date());
}
function createDuration(input) {
  if (typeof input === "number") {
    input = { seconds: input };
  } else if (typeof input === "string") {
    let seconds = 0, exp = 2;
    for (let part of input.split(":", 3)) {
      seconds += parseInt(part, 10) * Math.pow(60, exp--);
    }
    input = { seconds };
  } else if (input instanceof Date) {
    input = { hours: input.getUTCHours(), minutes: input.getUTCMinutes(), seconds: input.getUTCSeconds() };
  }
  let weeks = input.weeks || input.week || 0;
  return {
    years: input.years || input.year || 0,
    months: input.months || input.month || 0,
    days: weeks * 7 + (input.days || input.day || 0),
    seconds: (input.hours || input.hour || 0) * 60 * 60 + (input.minutes || input.minute || 0) * 60 + (input.seconds || input.second || 0),
    inWeeks: !!weeks
  };
}
function cloneDate(date) {
  return new Date(date.getTime());
}
function addDuration(date, duration, x) {
  if (x === void 0) {
    x = 1;
  }
  date.setUTCFullYear(date.getUTCFullYear() + x * duration.years);
  let month = date.getUTCMonth() + x * duration.months;
  date.setUTCMonth(month);
  month %= 12;
  if (month < 0) {
    month += 12;
  }
  while (date.getUTCMonth() !== month) {
    subtractDay(date);
  }
  date.setUTCDate(date.getUTCDate() + x * duration.days);
  date.setUTCSeconds(date.getUTCSeconds() + x * duration.seconds);
  return date;
}
function subtractDuration(date, duration, x) {
  return addDuration(date, duration, x === void 0 ? -1 : -x);
}
function addDay(date, x) {
  date.setUTCDate(date.getUTCDate() + (x === void 0 ? 1 : x));
  return date;
}
function subtractDay(date, x) {
  return addDay(date, x === void 0 ? -1 : -x);
}
function setMidnight(date) {
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function toLocalDate(date) {
  return new Date(
    date.getUTCFullYear(),
    date.getUTCMonth(),
    date.getUTCDate(),
    date.getUTCHours(),
    date.getUTCMinutes(),
    date.getUTCSeconds()
  );
}
function toISOString(date) {
  return date.toISOString().substring(0, 19);
}
function formatRange(start, end, intl2) {
  if (start.getFullYear() !== end.getFullYear()) {
    return intl2.format(start) + " - " + intl2.format(end);
  }
  let diff = [];
  if (start.getMonth() !== end.getMonth()) {
    diff.push("month");
  }
  if (start.getDate() !== end.getDate()) {
    diff.push("day");
  }
  if (!diff.length) {
    return intl2.format(start);
  }
  let opts1 = intl2.resolvedOptions();
  let opts2 = {};
  for (let key of diff) {
    opts2[key] = opts1[key];
  }
  let intl22 = new Intl.DateTimeFormat(opts1.locale, opts2);
  let full1 = intl2.format(start);
  let full2 = intl2.format(end);
  let part1 = intl22.format(start);
  let part2 = intl22.format(end);
  let common = _commonChunks(full1, part1, full2, part2);
  if (common) {
    return common.head + part1 + " - " + part2 + common.tail;
  }
  return full1 + " - " + full2;
}
function datesEqual(date1, ...dates2) {
  return dates2.every((date2) => date1.getTime() === date2.getTime());
}
function nextClosestDay(date, day) {
  let diff = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff >= 0 ? diff : diff + 7));
  return date;
}
function prevClosestDay(date, day) {
  let diff = day - date.getUTCDay();
  date.setUTCDate(date.getUTCDate() + (diff <= 0 ? diff : diff - 7));
  return date;
}
function _fromLocalDate(date) {
  return new Date(Date.UTC(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds()
  ));
}
function _fromISOString(str) {
  const parts = str.match(/\d+/g);
  return new Date(Date.UTC(
    Number(parts[0]),
    Number(parts[1]) - 1,
    Number(parts[2]),
    Number(parts[3] || 0),
    Number(parts[4] || 0),
    Number(parts[5] || 0)
  ));
}
function _commonChunks(str1, substr1, str2, substr2) {
  let i = 0;
  while (i < str1.length) {
    let res1;
    [i, res1] = _cut(str1, substr1, i);
    if (!res1) {
      break;
    }
    let j = 0;
    while (j < str2.length) {
      let res2;
      [j, res2] = _cut(str2, substr2, j);
      if (!res2) {
        break;
      }
      if (res1.head === res2.head && res1.tail === res2.tail) {
        return res1;
      }
    }
  }
  return null;
}
function _cut(str, substr, from) {
  let start = str.indexOf(substr, from);
  if (start >= 0) {
    let end = start + substr.length;
    return [end, {
      head: str.substr(0, start),
      tail: str.substr(end)
    }];
  }
  return [-1, null];
}

// node_modules/@event-calendar/common/src/stores.js
function writable2(value, parser, start) {
  return {
    ...writable(parser ? parser(value) : value, start),
    parse: parser
  };
}
function derived2(stores, fn, initValue) {
  let storeValue = initValue;
  let hasSubscribers = false;
  let auto = fn.length < 2;
  let fn2 = (_, set) => {
    hasSubscribers = true;
    if (auto) {
      storeValue = fn(_, set);
      set(storeValue);
    } else {
      fn(_, (value) => {
        storeValue = value;
        set(value);
      });
    }
    return () => {
      hasSubscribers = false;
    };
  };
  let store = derived(stores, fn2, storeValue);
  return {
    ...store,
    get: () => hasSubscribers ? storeValue : get_store_value(store)
  };
}
function intl(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    let intl2 = is_function($format) ? { format: $format } : new Intl.DateTimeFormat($locale, $format);
    return {
      format: (date) => intl2.format(toLocalDate(date))
    };
  });
}
function intlRange(locale, format) {
  return derived([locale, format], ([$locale, $format]) => {
    if (is_function($format)) {
      return { format: (start, end) => $format(toLocalDate(start), toLocalDate(end)) };
    }
    let intl2 = new Intl.DateTimeFormat($locale, $format);
    return {
      format: (start, end) => formatRange(toLocalDate(start), toLocalDate(end), intl2)
    };
  });
}

// node_modules/@event-calendar/common/src/utils.js
function assign(...args) {
  return Object.assign(...args);
}
function isObject(test) {
  return typeof test === "object" && test !== null;
}
function symbol() {
  return Symbol("ec");
}

// node_modules/@event-calendar/common/src/actions.js
function setContent(node, content) {
  let actions = {
    update(content2) {
      while (node.firstChild) {
        node.removeChild(node.lastChild);
      }
      if (!isObject(content2)) {
        node.innerText = content2;
      } else if (content2.domNodes) {
        for (let child of content2.domNodes) {
          node.appendChild(child);
        }
      } else if (content2.html) {
        node.innerHTML = content2.html;
      }
    }
  };
  actions.update(content);
  return actions;
}
function outsideEvent(node, type) {
  const handlePointerDown = (jsEvent) => {
    if (node && !node.contains(jsEvent.target)) {
      node.dispatchEvent(
        new CustomEvent(type + "outside", { detail: { jsEvent } })
      );
    }
  };
  document.addEventListener(type, handlePointerDown, true);
  return {
    destroy() {
      document.removeEventListener(type, handlePointerDown, true);
    }
  };
}

// node_modules/@event-calendar/common/src/dom.js
function createElement(tag, className, html, text) {
  let el = document.createElement(tag);
  el.className = className;
  if (html) {
    el.innerHTML = html;
  } else if (text) {
    el.innerText = text;
  }
  return el;
}
function hasYScroll(el) {
  return el.scrollHeight > el.clientHeight;
}
function rect(el) {
  return el.getBoundingClientRect();
}
function ancestor(el, up) {
  while (up--) {
    el = el.parentElement;
  }
  return el;
}
function height(el) {
  return el.offsetHeight;
}
var fnProp = symbol();
function setFn(el, fn) {
  el[fnProp] = fn;
}
function hasFn(el) {
  return !!el[fnProp];
}
function runFn(el, ...args) {
  return el[fnProp](...args);
}

// node_modules/@event-calendar/common/src/view.js
function createView(view, _viewTitle, _currentRange, _activeRange) {
  return {
    type: view,
    title: _viewTitle,
    currentStart: _currentRange.start,
    currentEnd: _currentRange.end,
    activeStart: _activeRange.start,
    activeEnd: _activeRange.end,
    calendar: void 0
  };
}
function toViewWithLocalDates(view) {
  view = assign({}, view);
  view.currentStart = toLocalDate(view.currentStart);
  view.currentEnd = toLocalDate(view.currentEnd);
  view.activeStart = toLocalDate(view.activeStart);
  view.activeEnd = toLocalDate(view.activeEnd);
  return view;
}

// node_modules/@event-calendar/common/src/events.js
var display = ["background"];
var eventId = 1;
function createEvents(input) {
  return input.map((event) => ({
    id: "id" in event ? String(event.id) : `{generated-${eventId++}}`,
    resourceIds: Array.isArray(event.resourceIds) ? event.resourceIds.map(String) : "resourceId" in event ? [String(event.resourceId)] : [],
    allDay: event.allDay || false,
    start: createDate(event.start),
    end: createDate(event.end),
    title: event.title || "",
    titleHTML: event.titleHTML || "",
    editable: event.editable,
    startEditable: event.startEditable,
    durationEditable: event.durationEditable,
    display: display.includes(event.display) ? event.display : "auto",
    extendedProps: event.extendedProps || {},
    backgroundColor: event.backgroundColor || event.color
  }));
}
function createEventSources(input) {
  return input.map((source) => ({
    events: source.events,
    url: source.url && source.url.trimEnd("&") || "",
    method: source.method && source.method.toUpperCase() || "GET",
    extraParams: source.extraParams || {}
  }));
}
function createEventChunk(event, start, end) {
  return {
    start: event.start > start ? event.start : start,
    end: event.end < end ? event.end : end,
    event
  };
}
function sortEventChunks(chunks) {
  chunks.sort((a, b) => {
    if (a.start < b.start) {
      return -1;
    }
    if (a.start > b.start) {
      return 1;
    }
    return 0;
  });
}
function prepareEventChunks(chunks, hiddenDays) {
  let longChunks = {};
  if (chunks.length) {
    sortEventChunks(chunks);
    let prevChunk;
    for (let chunk of chunks) {
      let dates = [];
      let date = setMidnight(cloneDate(chunk.start));
      while (chunk.end > date) {
        if (!hiddenDays.includes(date.getUTCDay())) {
          dates.push(cloneDate(date));
          if (dates.length > 1) {
            let key = date.getTime();
            if (longChunks[key]) {
              longChunks[key].push(chunk);
            } else {
              longChunks[key] = [chunk];
            }
          }
        }
        addDay(date);
      }
      if (dates.length) {
        chunk.date = dates[0];
        chunk.days = dates.length;
        chunk.dates = dates;
        if (chunk.start < dates[0]) {
          chunk.start = dates[0];
        }
        if (setMidnight(cloneDate(chunk.end)) > dates[dates.length - 1]) {
          chunk.end = dates[dates.length - 1];
        }
      } else {
        chunk.date = setMidnight(cloneDate(chunk.start));
        chunk.days = 1;
        chunk.dates = [chunk.date];
      }
      if (prevChunk && datesEqual(prevChunk.date, chunk.date)) {
        chunk.prev = prevChunk;
      }
      prevChunk = chunk;
    }
  }
  return longChunks;
}
function createEventContent(chunk, displayEventEnd, eventContent, theme, _intlEventTime, _view) {
  let timeText = _intlEventTime.format(chunk.start), content;
  if (displayEventEnd && chunk.event.display !== "pointer") {
    timeText += ` - ${_intlEventTime.format(chunk.end)}`;
  }
  if (eventContent) {
    content = is_function(eventContent) ? eventContent({
      event: toEventWithLocalDates(chunk.event),
      timeText,
      view: toViewWithLocalDates(_view)
    }) : eventContent;
  } else {
    switch (chunk.event.display) {
      case "background":
        content = "";
        break;
      case "pointer":
        content = {
          domNodes: [createElement("div", theme.eventTime, null, timeText)]
        };
        break;
      default:
        content = {
          domNodes: [
            createElement("div", theme.eventTime, null, timeText),
            createElement("div", theme.eventTitle, chunk.event.titleHTML, chunk.event.title)
          ]
        };
    }
  }
  return [timeText, content];
}
function toEventWithLocalDates(event) {
  return _cloneEvent(event, toLocalDate);
}
function _cloneEvent(event, dateFn) {
  event = assign({}, event);
  event.start = dateFn(event.start);
  event.end = dateFn(event.end);
  return event;
}

// node_modules/@event-calendar/common/src/jsevents.js
var ignoreProp = symbol();
function ignore(jsEvent) {
  jsEvent[ignoreProp] = true;
}
function maybeIgnore(fn) {
  return (jsEvent) => {
    if (!jsEvent[ignoreProp]) {
      fn && fn(jsEvent);
      ignore(jsEvent);
    }
  };
}

export {
  assign,
  setContent,
  outsideEvent,
  DAY_IN_SECONDS,
  createDate,
  createDuration,
  cloneDate,
  addDuration,
  subtractDuration,
  addDay,
  subtractDay,
  setMidnight,
  toLocalDate,
  toISOString,
  datesEqual,
  nextClosestDay,
  prevClosestDay,
  hasYScroll,
  rect,
  ancestor,
  height,
  setFn,
  hasFn,
  runFn,
  createView,
  toViewWithLocalDates,
  createEvents,
  createEventSources,
  createEventChunk,
  sortEventChunks,
  prepareEventChunks,
  createEventContent,
  toEventWithLocalDates,
  ignore,
  maybeIgnore,
  writable2,
  derived2,
  intl,
  intlRange
};
//# sourceMappingURL=chunk-6RAYDXBS.js.map
